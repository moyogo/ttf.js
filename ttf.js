/**
 * ttf.js - JavaScript TrueType Font library.
 * Copyright (c) 2013 ynakajima (http://github.com/ynakajima)
 *
 * Released under the MIT license.
 * https://github.com/ynakajima/ttf.js/blob/master/LICENSE.txt
 * 
 * The author of the parts:
 * Copyright (c) 2000,2001,2002,2003,2004,2005,2006,2007,2008 George Williams
 * Copyright Mathias Bynens <http://mathiasbynens.be/>
 *
 */        
// Generated by CoffeeScript 1.4.0
(function() {
  var AnchorTable, AttachmentListTable, BaseArray, CaretValueTable, ChainContextPositioning, ChainPosClassRule, ChainPosClassSet, ChainPosRule, ClassDefinitionTable, CmapSubTable, CmapTable, Common, CompositeGlyphData, ContextPositioning, CoverageTable, CursiveAttachment, DeviceTable, ExtensionPositioning, FeatureListTable, FeatureTable, GDEFTable, GPOSLookupType, GPOSTable, GSUBLookupType, GlyfTable, Glyph, HeadTable, HheaTable, HmtxTable, LangSys, LigCaretListTable, LigatureArray, LigatureAttach, LocaTable, Lookup, LookupListTable, LookupTable, Mark2Array, MarkArray, MarkGlyphSetsDef, MarkToBaseAttachment, MarkToLigatureAttachment, MarkToMarkAttachment, MaxpTable, NameTable, OS_2Table, PairAdjustment, PairSet, PosClassRule, PosClassSet, PosRule, PosRuleSet, PostTable, ScriptListTable, ScriptTable, SimpleGlyphData, SingleAdjustment, TTFDataView, TTFString, TrueType, ValueRecord, jDataView, standardNames, ttfjs, valueFormatLength;

  CompositeGlyphData = (function() {

    function CompositeGlyphData(GID, glyfTable) {
      if (GID == null) {
        GID = null;
      }
      if (glyfTable == null) {
        glyfTable = null;
      }
      this.GID = GID;
      this.type = 'composite';
      this.numberOfContours = 0;
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.glyfTable = glyfTable;
      this.components = [];
    }

    CompositeGlyphData.prototype.toSVGPathString = function(options) {
      var component, glyph, m, matrix, newMatrix, pathString, relative, t, _m, _matrix, _ref, _ref1;
      matrix = (_ref = options != null ? options.matrix : void 0) != null ? _ref : void 0;
      relative = (_ref1 = options != null ? options.relative : void 0) != null ? _ref1 : false;
      pathString = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.components;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          component = _ref2[_i];
          t = component.transform;
          glyph = this.glyfTable.getGlyphById(component.glyphIndex);
          _matrix = {
            a: 1,
            c: 0,
            e: component.offsetX,
            b: 0,
            d: 1,
            f: component.offsetY
          };
          if (typeof t.scale !== 'undefined') {
            _matrix.a = _matrix.d = t.scale;
          }
          if (typeof t.xScale !== 'undefined') {
            _matrix.a = t.xScale;
          }
          if (typeof t.xScale !== 'undefined') {
            _matrix.d = t.yScale;
          }
          if (typeof t.scale01 !== 'undefined') {
            _matrix.b = t.scale01;
          }
          if (typeof t.scale10 !== 'undefined') {
            _matrix.c = t.scale10;
          }
          if (typeof matrix !== 'undefined') {
            m = matrix;
            _m = _matrix;
            newMatrix = {
              a: m.a * _m.a + m.c * _m.b,
              c: m.a * _m.c + m.c * _m.d,
              e: m.a * _m.e + m.c * _m.f + m.e,
              b: m.b * _m.a + m.d * _m.b,
              d: m.b * _m.c + m.d * _m.d,
              f: m.b * _m.e + m.d * _m.f + m.f
            };
            _matrix = newMatrix;
          }
          _results.push(glyph.toSVGPathString({
            matrix: _matrix,
            relative: relative
          }));
        }
        return _results;
      }).call(this);
      return pathString.join(' ');
    };

    CompositeGlyphData.createFromTTFDataView = function(view, offset, glyphID, glyfTable) {
      var ARGS_ARE_XY_VALUES, ARG_1_AND_2_ARE_WORDS, MORE_COMPONENTS, OVERLAP_COMPOUND, RESERVED, ROUND_XY_TO_GRID, SCALED_COMPONENT_OFFSET, UNSCALED_COMPONENT_OFFSET, USE_MY_METRICS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO, WE_HAVE_INSTRUCTIONS, component, do_, flags, g, transform;
      ARG_1_AND_2_ARE_WORDS = Math.pow(2, 0);
      ARGS_ARE_XY_VALUES = Math.pow(2, 1);
      ROUND_XY_TO_GRID = Math.pow(2, 2);
      WE_HAVE_A_SCALE = Math.pow(2, 3);
      RESERVED = Math.pow(2, 4);
      MORE_COMPONENTS = Math.pow(2, 5);
      WE_HAVE_AN_X_AND_Y_SCALE = Math.pow(2, 6);
      WE_HAVE_A_TWO_BY_TWO = Math.pow(2, 7);
      WE_HAVE_INSTRUCTIONS = Math.pow(2, 8);
      USE_MY_METRICS = Math.pow(2, 9);
      OVERLAP_COMPOUND = Math.pow(2, 10);
      SCALED_COMPONENT_OFFSET = Math.pow(2, 11);
      UNSCALED_COMPONENT_OFFSET = Math.pow(2, 12);
      view.seek(offset);
      g = new CompositeGlyphData(glyphID, glyfTable);
      g.numberOfContours = view.getShort();
      g.xMin = view.getShort();
      g.yMin = view.getShort();
      g.xMax = view.getShort();
      g.yMax = view.getShort();
      do_ = MORE_COMPONENTS;
      g.components = (function() {
        var _results;
        _results = [];
        while (do_ === MORE_COMPONENTS) {
          component = {
            offsetX: 0,
            offsetY: 0
          };
          component.flags = view.getUshort();
          component.glyphIndex = view.getUshort();
          flags = component.flags;
          if (flags & ARG_1_AND_2_ARE_WORDS) {
            if (flags & ARGS_ARE_XY_VALUES) {
              component.offsetX = view.getShort();
              component.offsetY = view.getShort();
            } else {
              component.points = [view.getShort(), view.getShort()];
            }
          } else {
            if (flags & ARGS_ARE_XY_VALUES) {
              component.offsetX = view.getChar();
              component.offsetY = view.getChar();
            } else {
              component.points = [view.getChar(), view.getChar()];
            }
          }
          component.transform = transform = {};
          if (flags & WE_HAVE_A_SCALE) {
            transform.scale = view.getF2dot14();
          } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
            transform.xScale = view.getF2dot14();
            transform.yScale = view.getF2dot14();
          } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
            transform.xScale = view.getF2dot14();
            transform.scale01 = view.getF2dot14();
            transform.scale10 = view.getF2dot14();
            transform.yScale = view.getF2dot14();
          }
          do_ = flags & MORE_COMPONENTS;
          _results.push(component);
        }
        return _results;
      })();
      return g;
    };

    CompositeGlyphData.createFromJSON = function(json, glyfTable) {
      var g;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      g = new CompositeGlyphData(json.GID, glyfTable);
      g.numberOfContours = json.numberOfContours;
      g.xMin = json.xMin;
      g.yMin = json.yMin;
      g.xMax = json.xMax;
      g.yMax = json.yMax;
      g.components = json.components;
      return g;
    };

    return CompositeGlyphData;

  })();


  Glyph = (function() {

    function Glyph(glyphData, ttf) {
      this.glyphData = glyphData;
      this.GID = glyphData.GID;
      this.type = glyphData.type;
      this.numberOfContours = glyphData.numberOfContours;
      this.xMin = glyphData.xMin;
      this.yMin = glyphData.yMin;
      this.xMax = glyphData.xMax;
      this.yMax = glyphData.yMax;
      this.hmtx = {
        advanceWidth: (ttf.hmtx.hMetrics[this.GID] != null) && ttf.hmtx.hMetrics[this.GID].advanceWidth || ttf.hmtx.hMetrics[ttf.hmtx.hMetrics.length - 1],
        lbs: (ttf.hmtx.hMetrics[this.GID] != null) && ttf.hmtx.hMetrics[this.GID].lsb || ttf.hmtx.leftSideBearing[this.GID - ttf.hmtx.hMetrics.length]
      };
    }

    Glyph.prototype.toSVGPathString = function(options) {
      if (options == null) {
        options = {};
      }
      return this.glyphData.toSVGPathString(options);
    };

    return Glyph;

  })();


  SimpleGlyphData = (function() {

    function SimpleGlyphData(GID, glyfTable) {
      if (GID == null) {
        GID = null;
      }
      if (glyfTable == null) {
        glyfTable = null;
      }
      this.GID = GID;
      this.type = 'simple';
      this.numberOfContours = 0;
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.endPtsOfContours = [];
      this.instructionLength = 0;
      this.instructions = [];
      this.flags = [];
      this.xCoordinates = [];
      this.yCoordinates = [];
      this.glyfTable = glyfTable;
      this._outline = [];
      this.setOutline = function(outline) {
        this._outline = outline != null ? outline : [];
        return this;
      };
      this.getOutline = function() {
        return this._outline;
      };
    }

    SimpleGlyphData.prototype.toSVGPathString = function(options) {
      var after_contour, c, contour, coordinate, currentPoint, distance, end, i, j, k, matrix, midPoint, next, outline, pathString, prev, relative, segment, start, startIndex, _contour, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      matrix = (_ref = options != null ? options.matrix : void 0) != null ? _ref : void 0;
      relative = (_ref1 = options != null ? options.relative : void 0) != null ? _ref1 : false;
      outline = this.getTramsformedOutline(matrix);
      pathString = [];
      for (i = _i = 0, _len = outline.length; _i < _len; i = ++_i) {
        contour = outline[i];
        _contour = [];
        startIndex = 0;
        start = contour[0];
        if (!start.on) {
          if (contour.length > 1) {
            startIndex = 1;
            next = contour[1];
            if (!next.on) {
              _contour.push({
                x: start.x + (next.x - start.x) / 2,
                y: start.y + (next.y - start.y) / 2,
                on: true
              });
            }
          }
        }
        after_contour = [];
        for (j = _j = 0, _len1 = contour.length; _j < _len1; j = ++_j) {
          coordinate = contour[j];
          coordinate = {
            x: coordinate.x,
            y: coordinate.y,
            on: coordinate.on
          };
          if (j < startIndex) {
            after_contour.push(coordinate);
          } else {
            _contour.push(coordinate);
          }
        }
        _contour = _contour.concat(after_contour);
        start = _contour[0];
        end = _contour[_contour.length - 1];
        for (k = _k = 0, _len2 = _contour.length; _k < _len2; k = ++_k) {
          c = _contour[k];
          if (k === 0) {
            pathString.push('M ' + [c.x, c.y].join(','));
            currentPoint = c;
          } else {
            prev = _contour[k - 1];
            distance = {
              x: c.x - prev.x,
              y: c.y - prev.y,
              relX: c.x - currentPoint.x,
              relY: c.y - currentPoint.y
            };
            if (prev.on && c.on) {
              if (distance.y === 0) {
                segment = relative ? 'h ' + distance.relX : 'H ' + c.x;
                pathString.push(segment);
              } else if (distance.x === 0) {
                segment = relative ? 'v ' + distance.relY : 'V ' + c.y;
                pathString.push(segment);
              } else {
                segment = relative ? 'l ' + [distance.relX, distance.relY].join(',') : 'L ' + [c.x, c.y].join(',');
                pathString.push(segment);
              }
              currentPoint = c;
            } else if (prev.on && !c.on) {
              segment = relative ? 'q ' + [distance.relX, distance.relY].join(',') : 'Q ' + [c.x, c.y].join(',');
              pathString.push(segment);
            } else if (!prev.on && !c.on) {
              midPoint = {
                x: prev.x + (distance.x / 2),
                y: prev.y + (distance.y / 2),
                on: true
              };
              segment = relative ? [midPoint.x - currentPoint.x, midPoint.y - currentPoint.y].join(',') + ' t' : [midPoint.x, midPoint.y].join(',') + ' T';
              pathString.push(segment);
              currentPoint = midPoint;
            } else {
              segment = relative ? [distance.relX, distance.relY].join(',') : [c.x, c.y].join(',');
              pathString.push(segment);
              currentPoint = c;
            }
          }
        }
        if (end.on) {
          pathString.push('Z');
        } else if (relative) {
          pathString.push([start.x - currentPoint.x, start.y - currentPoint.y].join(',') + ' Z');
        } else {
          pathString.push([start.x, start.y].join(',') + ' Z');
        }
      }
      return pathString.join(' ');
    };

    SimpleGlyphData.prototype.getTramsformedOutline = function(matrix) {
      var contour, coordinate, _i, _len, _ref, _results;
      if (typeof matrix === 'undefined') {
        matrix = {
          a: 1,
          c: 0,
          e: 0,
          b: 0,
          d: 1,
          f: 0
        };
      }
      _ref = this.getOutline();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        contour = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = contour.length; _j < _len1; _j++) {
            coordinate = contour[_j];
            _results1.push({
              x: matrix.a * coordinate.x + matrix.c * coordinate.y + matrix.e,
              y: matrix.b * coordinate.x + matrix.d * coordinate.y + matrix.f,
              on: coordinate.on
            });
          }
          return _results1;
        })());
      }
      return _results;
    };

    SimpleGlyphData.createFromTTFDataView = function(view, offset, glyphID, glyfTable) {
      var ON_CURVE, POSITIVE_X_SHORT, POSITIVE_Y_SHORT, REPEAT, X_IS_SAME, X_SHORT, Y_IS_SAME, Y_SHORT, contour, endPtOfcountour, flag, flags, g, i, j, numRepeat, numberOfCoordinates, outline, relX, relY, startPtOfContour, x, y, _i;
      ON_CURVE = Math.pow(2, 0);
      X_SHORT = Math.pow(2, 1);
      Y_SHORT = Math.pow(2, 2);
      REPEAT = Math.pow(2, 3);
      X_IS_SAME = Math.pow(2, 4);
      POSITIVE_X_SHORT = Math.pow(2, 4);
      Y_IS_SAME = Math.pow(2, 5);
      POSITIVE_Y_SHORT = Math.pow(2, 5);
      view.seek(offset);
      g = new SimpleGlyphData(glyphID, glyfTable);
      g.numberOfContours = view.getShort();
      if (g.numberOfContours === 0) {
        return g;
      }
      g.xMin = view.getShort();
      g.yMin = view.getShort();
      g.xMax = view.getShort();
      g.yMax = view.getShort();
      g.endPtsOfContours = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = g.numberOfContours; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(view.getUshort());
        }
        return _results;
      })();
      numberOfCoordinates = g.endPtsOfContours[g.endPtsOfContours.length - 1] + 1;
      g.instructionLength = view.getUshort();
      if (g.instructionLength > 0) {
        g.instructions = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 1, _ref = g.instructionLength; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            _results.push(view.getByte());
          }
          return _results;
        })();
      }
      flags = [];
      i = 0;
      while (i < numberOfCoordinates) {
        flag = view.getByte();
        flags.push(flag);
        i++;
        if (flag & REPEAT) {
          numRepeat = view.getByte();
          for (j = _i = 1; 1 <= numRepeat ? _i <= numRepeat : _i >= numRepeat; j = 1 <= numRepeat ? ++_i : --_i) {
            if (i < numberOfCoordinates) {
              flags.push(flag);
              i++;
            }
          }
        }
      }
      g.flags = flags;
      g.xCoordinates = (function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = flags.length; _j < _len; _j++) {
          flag = flags[_j];
          x = 0;
          if (flag & X_SHORT) {
            _results.push(x = (flag & POSITIVE_X_SHORT ? 1 : -1) * view.getByte());
          } else {
            _results.push(x = flag & X_IS_SAME ? 0 : view.getShort());
          }
        }
        return _results;
      })();
      g.yCoordinates = (function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = flags.length; _j < _len; _j++) {
          flag = flags[_j];
          y = 0;
          if (flag & Y_SHORT) {
            _results.push(y = (flag & POSITIVE_Y_SHORT ? 1 : -1) * view.getByte());
          } else {
            _results.push(y = flag & Y_IS_SAME ? 0 : view.getShort());
          }
        }
        return _results;
      })();
      startPtOfContour = x = y = 0;
      outline = (function() {
        var _j, _len, _ref, _results;
        _ref = g.endPtsOfContours;
        _results = [];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          endPtOfcountour = _ref[_j];
          contour = (function() {
            var _k, _results1;
            _results1 = [];
            for (i = _k = startPtOfContour; startPtOfContour <= endPtOfcountour ? _k <= endPtOfcountour : _k >= endPtOfcountour; i = startPtOfContour <= endPtOfcountour ? ++_k : --_k) {
              x += relX = g.xCoordinates[i];
              y += relY = g.yCoordinates[i];
              _results1.push({
                x: x,
                y: y,
                on: flags[i] & ON_CURVE === ON_CURVE
              });
            }
            return _results1;
          })();
          startPtOfContour = endPtOfcountour + 1;
          _results.push(contour);
        }
        return _results;
      })();
      g.setOutline(outline);
      return g;
    };

    SimpleGlyphData.createFromJSON = function(json, glyfTable) {
      var g;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      g = new SimpleGlyphData(json.GID, glyfTable);
      g.numberOfContours = json.numberOfContours;
      g.xMin = json.xMin;
      g.yMin = json.yMin;
      g.xMax = json.xMax;
      g.yMax = json.yMax;
      g.endPtsOfContours = json.endPtsOfContours;
      g.instructionLength = json.instructionLength;
      g.instructions = json.instructions;
      g.flags = json.flags;
      g.xCoordinates = json.xCoordinates;
      g.yCoordinates = json.yCoordinates;
      g.setOutline(json._outline);
      return g;
    };

    return SimpleGlyphData;

  })();


  CmapTable = (function() {

    function CmapTable() {
      this.tableVersion = 0;
      this.tables = [];
    }

    CmapTable.createFromTTFDataView = function(view, offset, ttf) {
      var cmap, encodingId, i, indeces, index, numSubTables, platformId, subTable, subTableOffset, _i, _ref;
      view.seek(offset);
      cmap = new CmapTable();
      cmap.tableVersion = view.getUshort();
      numSubTables = view.getUshort();
      indeces = [];
      for (i = _i = 0, _ref = numSubTables - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        view.seek(offset + (i * 8) + 4);
        platformId = view.getUshort();
        encodingId = view.getUshort();
        subTableOffset = view.getUlong();
        index = -1;
        if ((indeces.indexOf(subTableOffset)) === -1) {
          index = Object.keys(indeces).length;
          indeces.push(subTableOffset);
          subTable = CmapSubTable.createFromTTFDataView(view, offset + subTableOffset, ttf);
          subTable.platformId = [platformId];
          subTable.encodingId = [encodingId];
          cmap.tables.push(subTable);
        } else {
          index = indeces.indexOf(subTableOffset);
          cmap.tables[index].platformId.push(platformId);
          cmap.tables[index].encodingId.push(encodingId);
        }
      }
      return cmap;
    };

    CmapTable.createFromJSON = function(json) {
      var cmap, i, _i, _ref;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      cmap = new CmapTable();
      cmap.tableVersion = json.tableVersion;
      for (i = _i = 0, _ref = json.tables.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        cmap.tables[i] = CmapSubTable.createFromJSON(json.tables[i]);
      }
      return cmap;
    };

    CmapTable.prototype.getGlyphIndex = function(character) {
      var glyphIds, map, table, _i, _j, _len, _len1, _ref;
      glyphIds = [];
      _ref = this.tables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        table = _ref[_i];
        console.log(table);
        if (table.isUnicode()) {
          for (_j = 0, _len1 = mapping.length; _j < _len1; _j++) {
            map = mapping[_j];
            if (map.code === character) {
              glyphIds.push(map.gId);
            }
          }
        }
      }
      return glyphIds;
    };

    return CmapTable;

  })();

  CmapSubTable = (function() {

    function CmapSubTable() {
      this.platformId = null;
      this.encodingId = null;
    }

    CmapSubTable.createFromTTFDataView = function(view, offset, ttf) {
      var additionalCount, charCode, codePoint, currentOffset, defaultUVSOffset, endCharCode, endCount, entryCount, entrySelector, firstCode, glyphId, glyphIndexArray, hiBytes, i, id, idDelta, idRangeOffset, is32, j, k, length, map, mapping, maxSubHeaderIndex, nGroups, nonDefaultUVSOffset, numChars, numUVSMappings, numUnicodeValueRanges, numVarSelectorRecords, rangeOffset, rangeShift, reservePad, reserved, searchRange, segCount, startCharCode, startCount, startGlyphId, startUnicodeValue, subHeaderIndex, subHeaderKey, subHeaderKeys, subHeaders, subTable, unicodeValue, unicodeValueRanges, varSelector, varSelectorRecords, _aa, _ab, _ac, _ad, _ae, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w, _x, _y, _z;
      view.seek(offset);
      subTable = new CmapSubTable();
      subTable.format = view.getUshort();
      mapping = [];
      if (subTable.format === 0) {
        length = view.getUshort();
        subTable.language = view.getUshort();
        for (i = _i = 0; _i <= 255; i = ++_i) {
          glyphId = view.getByte();
          map = {
            code: '0x' + i.toString(16),
            gId: glyphId
          };
          mapping.push = map;
        }
      }
      if (subTable.format === 2) {
        length = view.getUshort();
        subTable.language = view.getUshort();
        subHeaderKeys = {};
        maxSubHeaderIndex = 0;
        for (subHeaderKey = _j = 0; _j <= 255; subHeaderKey = ++_j) {
          subHeaderIndex = view.getUshort() / 8;
          if (subHeaderIndex > 0) {
            subHeaderKeys[subHeaderIndex] = subHeaderKey;
            if (maxSubHeaderIndex < subHeaderIndex) {
              maxSubHeaderIndex = subHeaderIndex;
            }
          }
        }
        subHeaders = [];
        glyphIndexArray = [];
        for (subHeaderIndex = _k = 0; 0 <= maxSubHeaderIndex ? _k <= maxSubHeaderIndex : _k >= maxSubHeaderIndex; subHeaderIndex = 0 <= maxSubHeaderIndex ? ++_k : --_k) {
          firstCode = view.getUshort();
          entryCount = view.getUshort();
          idDelta = view.getShort();
          idRangeOffset = view.getUshort();
          currentOffset = offset + 6 + 256 * 2 + (subHeaderIndex + 1) * 8;
          rangeOffset = currentOffset + idRangeOffset;
          view.seek(rangeOffset);
          if (subHeaderIndex > 0) {
            hiBytes = subHeaderKeys[subHeaderIndex];
          }
          for (id = _l = 0, _ref = entryCount - 1; 0 <= _ref ? _l <= _ref : _l >= _ref; id = 0 <= _ref ? ++_l : --_l) {
            glyphId = view.getUshort();
            if (glyphId > 0) {
              glyphId = (glyphId + idDelta) % 0x10000;
              charCode = id + firstCode;
              if (subHeaderIndex > 0) {
                charCode = hiBytes * 256 + charCode;
              }
              map = {
                code: '0x' + charCode.toString(16),
                gId: glyphId
              };
              mapping.push(map);
            }
          }
          view.seek(currentOffset);
        }
      }
      if (subTable.format === 4) {
        length = view.getUshort();
        subTable.language = view.getUshort();
        segCount = view.getUshort() >> 1;
        searchRange = view.getUshort();
        entrySelector = view.getUshort();
        rangeShift = view.getUshort();
        endCount = Array(segCount);
        for (i = _m = 0, _ref1 = segCount - 1; 0 <= _ref1 ? _m <= _ref1 : _m >= _ref1; i = 0 <= _ref1 ? ++_m : --_m) {
          endCount[i] = view.getUshort();
        }
        reservePad = view.getUshort();
        startCount = Array(segCount);
        for (i = _n = 0, _ref2 = segCount - 1; 0 <= _ref2 ? _n <= _ref2 : _n >= _ref2; i = 0 <= _ref2 ? ++_n : --_n) {
          startCount[i] = view.getUshort();
        }
        idDelta = Array(segCount);
        for (i = _o = 0, _ref3 = segCount - 1; 0 <= _ref3 ? _o <= _ref3 : _o >= _ref3; i = 0 <= _ref3 ? ++_o : --_o) {
          idDelta[i] = view.getShort();
        }
        idRangeOffset = Array(segCount);
        for (i = _p = 0, _ref4 = segCount - 1; 0 <= _ref4 ? _p <= _ref4 : _p >= _ref4; i = 0 <= _ref4 ? ++_p : --_p) {
          idRangeOffset[i] = view.getUshort();
        }
        for (i = _q = 0, _ref5 = segCount - 1; 0 <= _ref5 ? _q <= _ref5 : _q >= _ref5; i = 0 <= _ref5 ? ++_q : --_q) {
          for (j = _r = 0, _ref6 = endCount[i] - startCount[i]; 0 <= _ref6 ? _r <= _ref6 : _r >= _ref6; j = 0 <= _ref6 ? ++_r : --_r) {
            charCode = j + startCount[i];
            glyphId = charCode + idDelta[i];
            codePoint = '0x' + charCode.toString(16);
            mapping.push({
              code: codePoint,
              gId: glyphId
            });
          }
        }
      }
      if (subTable.format === 6) {
        length = view.getUshort();
        subTable.language = view.getUshort();
        firstCode = view.getUshort();
        entryCount = view.getUshort();
        for (i = _s = 0, _ref7 = entryCount - 1; 0 <= _ref7 ? _s <= _ref7 : _s >= _ref7; i = 0 <= _ref7 ? ++_s : --_s) {
          glyphId = view.getUshort();
          mapping.push({
            code: i + firstCode,
            gId: glyphId
          });
        }
      }
      if (subTable.format === 8) {
        reserved = view.getUshort();
        length = view.getUlong();
        subTable.language = view.getUlong();
        is32 = Array(8192);
        for (i = _t = 0; _t <= 8191; i = ++_t) {
          is32[i](view.getByte());
        }
        nGroups = view.getUlong();
        for (i = _u = 0; 0 <= nGroups ? _u <= nGroups : _u >= nGroups; i = 0 <= nGroups ? ++_u : --_u) {
          startCharCode = view.getUlong();
          endCharCode = view.getUlong();
          startGlyphId = view.getUlong();
          for (j = _v = startCharCode; startCharCode <= endCharCode ? _v <= endCharCode : _v >= endCharCode; j = startCharCode <= endCharCode ? ++_v : --_v) {
            mapping.push({
              code: j,
              gId: startGlyphId + j
            });
          }
        }
      }
      if (subTable.format === 10) {
        reserved = view.getUshort();
        length = view.getUlong();
        subTable.language = view.getUlong();
        startCharCode = view.getUlong();
        numChars = view.getUlong();
        for (i = _w = 0; 0 <= numChars ? _w <= numChars : _w >= numChars; i = 0 <= numChars ? ++_w : --_w) {
          mapping.push({
            code: startCharCode + i,
            gId: i
          });
        }
      }
      if (subTable.format === 12) {
        reserved = view.getUshort();
        length = view.getUlong();
        subTable.language = view.getUlong();
        nGroups = view.getUlong();
        for (i = _x = 0, _ref8 = nGroups - 1; 0 <= _ref8 ? _x <= _ref8 : _x >= _ref8; i = 0 <= _ref8 ? ++_x : --_x) {
          startCharCode = view.getUlong();
          endCharCode = view.getUlong();
          startGlyphId = view.getUlong();
          for (j = _y = 0, _ref9 = endCharCode - startCharCode; 0 <= _ref9 ? _y <= _ref9 : _y >= _ref9; j = 0 <= _ref9 ? ++_y : --_y) {
            charCode = startCharCode + j;
            codePoint = '0x' + charCode.toString(16);
            glyphId = startGlyphId + j;
            mapping.push({
              code: codePoint,
              gId: glyphId
            });
          }
        }
      }
      if (subTable.format === 13) {
        reserved = view.getUshort();
        length = view.getUlong();
        subTable.language = view.getLong();
        nGroups = view.getLong();
        for (i = _z = 0, _ref10 = nGroups - 1; 0 <= _ref10 ? _z <= _ref10 : _z >= _ref10; i = 0 <= _ref10 ? ++_z : --_z) {
          startCharCode = view.getUlong();
          endCharCode = view.getUlong();
          glyphId = view.getUlong();
          for (charCode = _aa = startCharCode; startCharCode <= endCharCode ? _aa <= endCharCode : _aa >= endCharCode; charCode = startCharCode <= endCharCode ? ++_aa : --_aa) {
            mapping.push({
              code: charCode,
              gId: glyphId
            });
          }
        }
      }
      if (subTable.format === 14) {
        length = view.getUlong();
        numVarSelectorRecords = view.getUlong();
        varSelectorRecords = Array(numVarSelectorRecords);
        for (i = _ab = 0, _ref11 = numVarSelectorRecords - 1; 0 <= _ref11 ? _ab <= _ref11 : _ab >= _ref11; i = 0 <= _ref11 ? ++_ab : --_ab) {
          currentOffset = offset + 2 + 4 + 4;
          varSelector = '0x' + view.getUint24().toString(16);
          defaultUVSOffset = view.getUlong();
          nonDefaultUVSOffset = view.getUlong();
          view.seek(offset + defaultUVSOffset);
          numUnicodeValueRanges = view.getUlong();
          unicodeValueRanges = [];
          for (j = _ac = 0; 0 <= numUnicodeValueRanges ? _ac <= numUnicodeValueRanges : _ac >= numUnicodeValueRanges; j = 0 <= numUnicodeValueRanges ? ++_ac : --_ac) {
            startUnicodeValue = view.getUint24();
            additionalCount = view.getByte();
            for (k = _ad = 0; 0 <= additionalCount ? _ad <= additionalCount : _ad >= additionalCount; k = 0 <= additionalCount ? ++_ad : --_ad) {
              charCode = startUnicodeValue + k;
              unicodeValueRanges.push({
                varSelector: varSelector,
                code: '0x' + charCode.toString(16)
              });
            }
          }
          view.seek(offset + nonDefaultUVSOffset);
          numUVSMappings = view.getUlong();
          for (j = _ae = 0, _ref12 = numUVSMappings - 1; 0 <= _ref12 ? _ae <= _ref12 : _ae >= _ref12; j = 0 <= _ref12 ? ++_ae : --_ae) {
            unicodeValue = view.getUint24();
            glyphId = view.getUshort();
            unicodeValueRanges.push({
              varSelector: varSelector,
              code: '0x' + unicodeValue.toString(16),
              gId: glyphId
            });
          }
          view.seek(currentOffset);
          varSelectorRecords[i] = unicodeValueRanges;
        }
        mapping = varSelectorRecords;
      }
      subTable.mapping = mapping;
      return subTable;
    };

    CmapSubTable.createFromJSON = function(json) {
      var subTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      subTable = new CmapSubTable();
      subTable.platformId = json.platformId;
      subTable.encodingId = json.encodingId;
      subTable.format = json.format;
      subTable.language = json.language;
      subTable.mapping = json.mapping;
      return subTable;
    };

    CmapSubTable.prototype.isUnicode = function() {
      return this.plaformId === 0 || (this.plaformId === 3 && (this.encodingId === 1 || this.encodingId === 1));
    };

    CmapSubTable.prototype.isSymbol = function() {
      return this.platformId === 3 && this.encodingId === 0;
    };

    return CmapSubTable;

  })();


  GPOSLookupType = {
    1: 'SingleAdjustment',
    2: 'PairAdjustment',
    3: 'CursiveAttachment',
    4: 'MarkToBaseAttachment',
    5: 'MarkToLigatureAttachment',
    6: 'MarkToMarkAttachment',
    7: 'ContextPositioning',
    8: 'ChainContextPositioning',
    9: 'ExtensionPositioning'
  };

  GSUBLookupType = {
    1: 'Single',
    2: 'Multiple',
    3: 'Alternate',
    4: 'Ligature',
    5: 'Context',
    6: 'ChainingContext',
    7: 'ExtensionSubstitution',
    8: 'ReverseChainingContextSingle'
  };

  valueFormatLength = function(valueFormat) {
    var length;
    length = (valueFormat & 0x0001) / 0x0001 + (valueFormat & 0x0002) / 0x0002 + (valueFormat & 0x0004) / 0x0004 + (valueFormat & 0x0008) / 0x0008 + (valueFormat & 0x0010) / 0x0010 + (valueFormat & 0x0020) / 0x0020 + (valueFormat & 0x0040) / 0x0040 + (valueFormat & 0x0080) / 0x0080;
    return length;
  };

  ScriptListTable = (function() {

    function ScriptListTable() {}

    ScriptListTable.createFromTTFDataView = function(view, offset) {
      var i, scriptCount, scriptListTable, scriptOffset, scriptRecord, scriptTable, scriptTag, _i, _ref;
      view.seek(offset);
      scriptListTable = new ScriptListTable();
      scriptListTable.scriptCount = scriptCount = view.getUshort();
      if (scriptCount > 0) {
        scriptRecord = Array(scriptCount);
        for (i = _i = 0, _ref = scriptCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 6);
          scriptTag = view.getString(4);
          scriptOffset = view.getUshort();
          scriptTable = ScriptTable.createFromTTFDataView(view, offset + scriptOffset);
          scriptRecord[i] = {
            scriptTag: scriptTag,
            script: scriptTable
          };
        }
      }
      scriptListTable.scriptRecord = scriptRecord;
      return scriptListTable;
    };

    ScriptListTable.createFromJSON = function(json) {
      var i, scriptListTable, _i, _ref;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      scriptListTable = new ScriptListTable();
      scriptListTable.scriptCount = json.scriptCount;
      for (i = _i = 0, _ref = json.scriptRecordlength; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        scriptListTable.scriptRecord = Array(json.scriptRecordlength);
        scriptListTable.scriptRecord[i] = {
          scriptTag: scriptRecord.scriptTag,
          script: ScriptTable.createFromJSON(scriptRecord.script)
        };
      }
      return scriptListTable;
    };

    return ScriptListTable;

  })();

  ScriptTable = (function() {

    function ScriptTable() {
      this.langSysCount = 0;
      this.langSysRecord = [];
    }

    ScriptTable.createFromTTFDataView = function(view, offset) {
      var defaultLangSysOffset, defaultLangSysRecord, i, langSys, langSysCount, langSysOffset, langSysRecord, langSysTag, scriptTable, _i, _ref;
      view.seek(offset);
      scriptTable = new ScriptTable();
      defaultLangSysOffset = view.getUshort();
      scriptTable.langSysCount = langSysCount = view.getUshort();
      langSysRecord = Array(langSysCount + 1);
      defaultLangSysRecord = {
        langSysTag: "dflt",
        langSys: LangSys.createFromTTFDataView(view, offset + defaultLangSysOffset)
      };
      langSysRecord[0] = defaultLangSysRecord;
      if (langSysCount > 0) {
        for (i = _i = 0, _ref = langSysCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 4 + i * 6);
          langSysTag = view.getString(4);
          langSysOffset = view.getUshort();
          langSys = LangSys.createFromTTFDataView(view, offset + langSysOffset);
          langSysRecord[i + 1] = {
            langSysTag: langSysTag,
            langSys: langSys
          };
        }
      }
      scriptTable.langSysRecord = langSysRecord;
      return scriptTable;
    };

    ScriptTable.createFromJSON = function(json) {
      var scriptTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      scriptTable = new ScriptTable();
      scriptTable.langSysCount = json.langSysCount;
      scriptTable.langSysRecord = json.langSysRecord;
      return scriptTable;
    };

    return ScriptTable;

  })();

  LangSys = (function() {

    function LangSys() {
      this.lookupOrder = null;
      this.reqFeatureIndex = 0xFFFF;
      this.featureCount = 0;
      this.featureIndex = [];
    }

    LangSys.createFromTTFDataView = function(view, offset) {
      var featureCount, featureIndex, i, langSys, _i, _ref;
      view.seek(offset);
      langSys = new LangSys();
      langSys.lookupOrder = view.getUshort();
      langSys.reqFeatureIndex = view.getUshort();
      langSys.featureCount = featureCount = view.getUshort();
      if (featureCount > 0) {
        featureIndex = Array(featureCount);
        for (i = _i = 0, _ref = featureCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          featureIndex[i] = view.getUshort();
        }
        langSys.featureIndex = featureIndex;
      }
      return langSys;
    };

    LangSys.createFromJSON = function(json) {
      var langSys;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      langSys = new langSys();
      langSys.lookupOrder = json.lookupOrder;
      langSys.reqFeatureIndex = json.lookupOrder;
      langSys.featureCount = json.featureCount;
      langSys.featureIndex = json.featureIndex;
      return langSys;
    };

    return LangSys;

  })();

  FeatureListTable = (function() {

    function FeatureListTable() {
      this.featureCount = 0;
      this.featureRecord = [];
    }

    FeatureListTable.createFromTTFDataView = function(view, offset) {
      var featureCount, featureListTable, featureOffset, featureRecord, featureTag, i, _i, _ref;
      view.seek(offset);
      featureListTable = new FeatureListTable();
      featureListTable.featureCount = featureCount = view.getUshort();
      if (featureCount > 0) {
        featureRecord = Array(featureCount);
        for (i = _i = 0, _ref = featureCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + 6 * i);
          featureTag = view.getString(4);
          featureOffset = view.getUshort();
          featureRecord[i] = {
            featureTag: featureTag,
            feature: FeatureTable.createFromTTFDataView(view, offset + featureOffset)
          };
        }
        featureListTable.featureRecord = featureRecord;
      }
      return featureListTable;
    };

    FeatureListTable.createFromJSON = function(json) {
      var featureListTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      featureListTable = new FeatureListTable();
      featureListTable.featureCount = json.featureCount;
      featureListTable.featureRecord = json.featureRecord;
      return featureListTable;
    };

    return FeatureListTable;

  })();

  FeatureTable = (function() {

    function FeatureTable() {
      this.featureParams = null;
      this.lookupCount = 0;
      this.lookupListIndex = [];
    }

    FeatureTable.createFromTTFDataView = function(view, offset) {
      var featureTable, i, lookupCount, lookupListIndex, _i, _ref;
      view.seek(offset);
      featureTable = new FeatureTable();
      featureTable.featureParams = view.getUshort();
      featureTable.lookupCount = lookupCount = view.getUshort();
      if (lookupCount > 0) {
        lookupListIndex = Array(lookupCount);
        for (i = _i = 0, _ref = lookupCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          lookupListIndex[i] = view.getUshort();
        }
        featureTable.lookupListIndex = lookupListIndex;
      }
      return featureTable;
    };

    FeatureTable.createFromJSON = function(json) {
      var featureTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      featureTable = new FeatureTable();
      featureTable.featureParams = json.featureParams;
      featureTable.lookupCount = json.lookupCount;
      featureTable.lookupListIndex = json.lookupListIndex;
      return featureTable;
    };

    return FeatureTable;

  })();

  LookupListTable = (function() {

    function LookupListTable() {
      this.lookupCount = 0;
      this.lookupTables = [];
    }

    LookupListTable.createFromTTFDataView = function(view, offset, tableType) {
      var i, lookupCount, lookupListTable, lookupOffset, lookupTable, lookupTables, _i, _ref;
      view.seek(offset);
      lookupListTable = new LookupListTable();
      lookupListTable.lookupCount = lookupCount = view.getUshort();
      if (lookupCount > 0) {
        lookupTables = Array(lookupCount);
        for (i = _i = 0, _ref = lookupCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          lookupOffset = view.getUshort();
          lookupTable = LookupTable.createFromTTFDataView(view, offset + lookupOffset, tableType);
          lookupTables[i] = lookupTable;
        }
        lookupListTable.lookupTables = lookupTables;
      }
      return lookupListTable;
    };

    LookupListTable.createFromJSON = function(json, tableType) {
      var lookupListTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      lookupListTable = new LookupListTable();
      lookupListTable.lookupCount = json.lookupCount;
      return lookupListTable;
    };

    return LookupListTable;

  })();

  LookupTable = (function() {

    function LookupTable() {
      this.lookupType = null;
      this.lookupFlag = null;
      this.subTableCount = 0;
    }

    LookupTable.createFromTTFDataView = function(view, offset, tableType) {
      var i, lookupTable, subTable, subTableCount, subTableOffset, subTables, _i, _ref;
      view.seek(offset);
      lookupTable = new LookupTable();
      lookupTable.lookupType = view.getUshort();
      lookupTable.lookupFlag = view.getUshort();
      lookupTable.subTableCount = subTableCount = view.getUshort();
      if (subTableCount > 0) {
        subTables = Array(subTableCount);
        for (i = _i = 0, _ref = subTableCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 6 + i * 2);
          subTableOffset = view.getUshort();
          subTable = Lookup.createFromTTFDataView(view, offset + subTableOffset, tableType, lookupTable.lookupType);
          subTables[i] = subTable;
        }
        lookupTable.subTables = subTables;
      }
      if (lookupTable.lookupFlag & 0x0010) {
        view.seek(offset + 4 + i * subTableCount);
        lookupTable.markFilteringSet = view.getUshort();
      }
      return lookupTable;
    };

    return LookupTable;

  })();

  Lookup = (function() {

    function Lookup() {}

    Lookup.createFromTTFDataView = function(view, offset, tableType, lookupType) {
      var lookupTypeClass, lookupTypeString, subTable;
      subTable = null;
      lookupTypeString = tableType + "LookupType[" + lookupType + "]";
      lookupTypeClass = eval(lookupTypeString);
      subTable = eval("subTable = " + lookupTypeClass + ".createFromTTFDataView(view, offset)");
      return subTable;
    };

    return Lookup;

  })();

  SingleAdjustment = (function() {

    function SingleAdjustment() {
      this.posFormat = null;
    }

    SingleAdjustment.createFromTTFDataView = function(view, offset) {
      var coverage, coverageOffset, formats, i, posFormat, singleAdjustment, value, valueCount, valueFormat, values, _i, _ref;
      view.seek(offset);
      singleAdjustment = new SingleAdjustment();
      singleAdjustment.posFormat = posFormat = view.getUshort();
      coverageOffset = view.getUshort();
      coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
      singleAdjustment.coverage = coverage;
      view.seek(offset + 4);
      valueFormat = view.getUshort();
      singleAdjustment.valueFormat = valueFormat;
      formats = valueFormatLength(valueFormat);
      if (posFormat === 1) {
        value = ValueRecord.createFromTTFDataView(view, offset + 6, valueFormat);
        singleAdjustment.value = value;
      }
      if (posFormat === 2) {
        valueCount = view.getUshort();
        if (valueCount > 0) {
          values = Array(valueCount);
          for (i = _i = 0, _ref = valueCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            value = ValueRecord.createFromTTFDataView(view, offset + 8 + i * 2 * formats, valueFormat);
            values[i] = value;
          }
          singleAdjustment.values = values;
        }
      }
      return singleAdjustment;
    };

    return SingleAdjustment;

  })();

  PairAdjustment = (function() {

    function PairAdjustment() {
      this.posFormat = 1;
    }

    PairAdjustment.createFromTTFDataView = function(view, offset) {
      var class1Count, class1Records, class2Count, classDef1, classDef1Offset, classDef2, classDef2Offset, coverage, coverageOffset, formats1, formats2, i, pairAdjustment, pairSet, pairSetCount, pairSetOffset, pairSets, posFormat, value1, value2, valueFormat1, valueFormat2, _i, _j, _ref, _ref1;
      view.seek(offset);
      pairAdjustment = new PairAdjustment();
      pairAdjustment.posFormat = posFormat = view.getUshort();
      if (posFormat === 1) {
        coverageOffset = view.getUshort();
        pairAdjustment.valueFormat1 = valueFormat1 = view.getUshort();
        pairAdjustment.valueFormat2 = valueFormat2 = view.getUshort();
        pairAdjustment.pairSetCount = pairSetCount = view.getUshort();
        coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
        pairAdjustment.coverage = coverage;
        if (pairSetCount > 0) {
          pairSets = Array(pairSetCount);
          for (i = _i = 0, _ref = pairSetCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            view.seek(offset + 10 + i * 2);
            pairSetOffset = view.getUshort();
            pairSet = PairSet.createFromTTFDataView(view, offset + pairSetOffset, valueFormat1, valueFormat2);
            pairSets[i] = pairSet;
          }
          pairAdjustment.pairSets = pairSets;
        }
      }
      if (posFormat === 2) {
        coverageOffset = view.getUshort();
        pairAdjustment.valueFormat1 = valueFormat1 = view.getUshort();
        pairAdjustment.valueFormat2 = valueFormat2 = view.getUshort();
        classDef1Offset = view.getUshort();
        classDef2Offset = view.getUshort();
        pairAdjustment.class1Count = class1Count = view.getUshort();
        pairAdjustment.class2Count = class2Count = view.getUshort();
        coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
        classDef1 = ClassDefinitionTable.createFromTTFDataView(view, offset + classDef1Offset);
        classDef2 = ClassDefinitionTable.createFromTTFDataView(view, offset + classDef2Offset);
        pairAdjustment.coverage = coverage;
        pairAdjustment.classDef1 = classDef1;
        pairAdjustment.classDef2 = classDef2;
        formats1 = valueFormatLength(valueFormat1);
        formats2 = valueFormatLength(valueFormat2);
        if (class1Count > 0) {
          class1Records = [];
          for (i = _j = 0, _ref1 = class1Count - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            value1 = ValueRecord.createFromTTFDataView(view, offset + 16 + i * 2 * formats1 + i * 2 * formats2, valueFormat1);
            value2 = ValueRecord.createFromTTFDataView(view, offset + 16 + (i + 1) * 2 * formats1 + i * 2 * formats2, valueFormat2);
          }
        }
      }
      return pairAdjustment;
    };

    return PairAdjustment;

  })();

  PairSet = (function() {

    function PairSet() {
      this.pairValueCount = 0;
    }

    PairSet.createFromTTFDataView = function(view, offset, valueFormat1, valueFormat2) {
      var formats1, formats2, i, pairSet, pairValue, pairValueCount, pairValues, secondGlyph, value1, value2, _i, _ref;
      view.seek(offset);
      pairSet = new PairSet();
      pairSet.pairValueCount = pairValueCount = view.getUshort();
      formats1 = (valueFormat1 & 0x0001) / 0x0001 + (valueFormat1 & 0x0002) / 0x0002 + (valueFormat1 & 0x0004) / 0x0004 + (valueFormat1 & 0x0008) / 0x0008 + (valueFormat1 & 0x0010) / 0x0010 + (valueFormat1 & 0x0020) / 0x0020 + (valueFormat1 & 0x0040) / 0x0040 + (valueFormat1 & 0x0080) / 0x0080;
      formats2 = (valueFormat1 & 0x0001) / 0x0001 + (valueFormat1 & 0x0002) / 0x0002 + (valueFormat1 & 0x0004) / 0x0004 + (valueFormat1 & 0x0008) / 0x0008 + (valueFormat1 & 0x0010) / 0x0010 + (valueFormat1 & 0x0020) / 0x0020 + (valueFormat1 & 0x0040) / 0x0040 + (valueFormat1 & 0x0080) / 0x0080;
      if (pairValueCount > 0) {
        pairValues = Array(pairValueCount);
        for (i = _i = 0, _ref = pairValueCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2 * formats1 + i * 2 * formats2);
          secondGlyph = view.getUshort();
          value1 = ValueRecord.createFromTTFDataView(view, offset + 4 + i * 2 * formats1 + i * 2 * formats2, valueFormat1);
          value2 = ValueRecord.createFromTTFDataView(view, offset + 4 + (i + 1) * 2 * formats1 + i * 2 * formats2, valueFormat2);
          pairValue = {
            secondGlyph: secondGlyph
          };
          if (valueFormat1) {
            pairValue.value1 = value1;
          }
          if (valueFormat2) {
            pairValue.value2 = value2;
          }
          pairValues[i] = pairValue;
        }
        pairSet.pairValues = pairValues;
      }
      return pairSet;
    };

    return PairSet;

  })();

  CursiveAttachment = (function() {

    function CursiveAttachment() {
      this.posFormat = 1;
    }

    CursiveAttachment.createFromTTFDataView = function(view, offset) {
      var coverage, coverageOffset, cursiveAttachment, entryAnchor, entryAnchorOffset, entryExitCount, entryExitRecord, entryExitRecords, exitAnchor, exitAnchorOffset, i, _i, _ref;
      view.seek(offset);
      cursiveAttachment = new CursiveAttachment();
      cursiveAttachment.posFormat = view.getUshort();
      coverageOffset = view.getUshort();
      cursiveAttachment.entryExitCount = entryExitCount = view.getUshort();
      coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
      cursiveAttachment.coverage = coverage;
      if (entryExitCount > 0) {
        entryExitRecords = Array(entryExitCount);
        for (i = _i = 0, _ref = entryExitCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 6 + i * 4);
          entryAnchorOffset = view.getUshort();
          exitAnchorOffset = view.getUshort();
          entryExitRecord = {};
          if (entryAnchorOffset !== 0) {
            entryAnchor = AnchorTable.createFromTTFDataView(view, offset + entryAnchorOffset);
            entryExitRecord.entryAnchor = entryAnchor;
          }
          if (exitAnchorOffset !== 0) {
            exitAnchor = AnchorTable.createFromTTFDataView(view, offset + exitAnchorOffset);
            entryExitRecord.exitAnchor = exitAnchor;
          }
          entryExitRecords[i] = entryExitRecord;
        }
        cursiveAttachment.entryExitRecords = entryExitRecords;
      }
      return cursiveAttachment;
    };

    return CursiveAttachment;

  })();

  MarkToBaseAttachment = (function() {

    function MarkToBaseAttachment() {
      this.posFormat = 1;
    }

    MarkToBaseAttachment.createFromTTFDataView = function(view, offset) {
      var baseArray, baseArrayOffset, baseCoverageOffset, classCount, markArray, markArrayOffset, markCoverageOffset, markToBaseAttachment;
      view.seek(offset);
      markToBaseAttachment = new MarkToBaseAttachment();
      markToBaseAttachment.posFormat = view.getUshort();
      markCoverageOffset = view.getUshort();
      baseCoverageOffset = view.getUshort();
      classCount = view.getUshort();
      markArrayOffset = view.getUshort();
      baseArrayOffset = view.getUshort();
      markToBaseAttachment.markCoverage = CoverageTable.createFromTTFDataView(view, offset + markCoverageOffset);
      markToBaseAttachment.baseCoverage = CoverageTable.createFromTTFDataView(view, offset + baseCoverageOffset);
      markArray = MarkArray.createFromTTFDataView(view, offset + markArrayOffset);
      baseArray = BaseArray.createFromTTFDataView(view, offset + baseArrayOffset);
      markToBaseAttachment.markArray = markArray;
      markToBaseAttachment.baseArray = baseArray;
      return markToBaseAttachment;
    };

    return MarkToBaseAttachment;

  })();

  MarkToLigatureAttachment = (function() {

    function MarkToLigatureAttachment() {}

    MarkToLigatureAttachment.createFromTTFDataView = function(view, offset) {
      var classCount, ligatureArray, ligatureArrayOffset, ligatureCoverage, ligatureCoverageOffset, markArray, markArrayOffset, markCoverage, markCoverageOffset, markToLigatureAttachment, posFormat;
      view.seek(offset);
      markToLigatureAttachment = new MarkToLigatureAttachment();
      markToLigatureAttachment.posFormat = posFormat = view.getUshort();
      markCoverageOffset = view.getUshort();
      ligatureCoverageOffset = view.getUshort();
      markToLigatureAttachment.classCount = classCount = view.getUshort();
      markArrayOffset = view.getUshort();
      ligatureArrayOffset = view.getUshort();
      markCoverage = CoverageTable.createFromTTFDataView(view, offset + markCoverageOffset);
      ligatureCoverage = CoverageTable.createFromTTFDataView(view, offset + ligatureCoverageOffset);
      markArray = MarkArray.createFromTTFDataView(view, offset + markArrayOffset);
      ligatureArray = LigatureArray.createFromTTFDataView(view, offset + ligatureArrayOffset, classCount);
      return markToLigatureAttachment;
    };

    return MarkToLigatureAttachment;

  })();

  LigatureArray = (function() {

    function LigatureArray() {}

    LigatureArray.createFromTTFDataView = function(view, offset, classCount) {
      var i, ligatureArray, ligatureAttach, ligatureAttachOffset, ligatureAttachs, ligatureCount, _i, _ref;
      view.seek(offset);
      ligatureArray = new LigatureArray();
      ligatureArray.ligatureCount = ligatureCount = view.getUshort();
      if (ligatureCount > 0) {
        ligatureAttachs = Array(ligatureCount);
        for (i = _i = 0, _ref = ligatureCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          ligatureAttachOffset = view.getUshort();
          ligatureAttach = LigatureAttach.createFromTTFDataView(view, offset + ligatureAttachOffset, classCount);
          ligatureAttachs[i] = ligatureAttach;
        }
        ligatureArray.ligatureAttachs = ligatureAttachs;
      }
      return ligatureArray;
    };

    return LigatureArray;

  })();

  LigatureAttach = (function() {

    function LigatureAttach() {}

    LigatureAttach.createFromTTFDataView = function(view, offset, classCount) {
      var componentCount, componentRecord, componentRecords, i, j, ligatureAnchor, ligatureAnchorOffset, ligatureAttach, _i, _j, _ref, _ref1;
      view.seek(offset);
      ligatureAttach = new LigatureAttach();
      ligatureAttach.componentCount = componentCount = view.getUshort();
      if (componentCount > 0) {
        componentRecords = Array(componentCount);
        for (i = _i = 0, _ref = componentCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (classCount > 0) {
            componentRecord = Array(classCount);
            for (j = _j = 0, _ref1 = classCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              view.seek(offset + 2 + i * 2 * classCount + j * 2);
              ligatureAnchorOffset = view.getUshort();
              ligatureAnchor = AnchorTable.createFromTTFDataView(view, offset + ligatureAnchorOffset);
              componentRecord[j] = ligatureAnchor;
            }
            componentRecords[i] = componentRecord;
          }
        }
      }
      ligatureAttach.componentRecords = componentRecords;
      return ligatureAttach;
    };

    return LigatureAttach;

  })();

  MarkToMarkAttachment = (function() {

    function MarkToMarkAttachment() {
      this.posFormat = 1;
    }

    MarkToMarkAttachment.createFromTTFDataView = function(view, offset) {
      var classCount, mark1Array, mark1ArrayOffset, mark1Coverage, mark1CoverageOffset, mark2Array, mark2ArrayOffset, mark2Coverage, mark2CoverageOffset, markToMarkAttachment, posFormat;
      view.seek(offset);
      markToMarkAttachment = new MarkToMarkAttachment();
      markToMarkAttachment.posFormat = posFormat = view.getUshort();
      mark1CoverageOffset = view.getUshort();
      mark2CoverageOffset = view.getUshort();
      markToMarkAttachment.classCount = classCount = view.getUshort();
      mark1ArrayOffset = view.getUshort();
      mark2ArrayOffset = view.getUshort();
      mark1Coverage = CoverageTable.createFromTTFDataView(view, offset + mark1CoverageOffset);
      mark2Coverage = CoverageTable.createFromTTFDataView(view, offset + mark2CoverageOffset);
      mark1Array = MarkArray.createFromTTFDataView(view, offset + mark1ArrayOffset);
      mark2Array = Mark2Array.createFromTTFDataView(view, offset + mark2ArrayOffset);
      markToMarkAttachment.mark1Coverage = mark1Coverage;
      markToMarkAttachment.mark2Coverage = mark2Coverage;
      markToMarkAttachment.mark1Array = mark1Array;
      markToMarkAttachment.mark2Array = mark2Array;
      return markToMarkAttachment;
    };

    return MarkToMarkAttachment;

  })();

  Mark2Array = (function() {

    function Mark2Array() {
      this.baseCount = 0;
    }

    Mark2Array.createFromTTFDataView = function(view, offset) {
      var i, mark2Anchor, mark2AnchorOffset, mark2Array, mark2Count, mark2Record, mark2Records, _i, _ref;
      view.seek(offset);
      mark2Array = new Mark2Array();
      mark2Array.mark2Count = mark2Count = view.getUshort();
      if (mark2Count > 0) {
        mark2Records = Array(mark2Count);
        for (i = _i = 0, _ref = mark2Count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          mark2AnchorOffset = view.getUshort();
          mark2Anchor = AnchorTable.createFromTTFDataView(view, offset + baseAnchorOffset);
          mark2Record = {
            mark2Anchor: mark2anchor
          };
          mark2Records[i] = mark2Record;
        }
      }
      mark2Array.mark2Records = mark2Records;
      return mark2Array;
    };

    return Mark2Array;

  })();

  Mark2Array = (function() {

    function Mark2Array() {}

    Mark2Array.createFromTTFDataView = function(view, offset) {
      var mark2AnchorOffset, mark2Array;
      view.seek(offset);
      mark2Array = new Mark2Array;
      return mark2AnchorOffset = view.getUshort();
    };

    return Mark2Array;

  })();

  ContextPositioning = (function() {

    function ContextPositioning() {}

    ContextPositioning.createFromTTFDataView = function(view, offset) {
      var classDef, classDefOffset, contextPositioning, coverage, coverageOffset, i, posClassSet, posClassSetCount, posClassSetOffset, posClassSets, posFormat, posRuleSet, posRuleSetCount, posRuleSetOffset, posRuleSets, _i, _j, _ref, _ref1;
      view.seek(offset);
      contextPositioning = new ContextPositioning();
      contextPositioning.posFormat = posFormat = view.getUshort();
      if (posFormat === 1) {
        coverageOffset = view.getUshort();
        contextPositioning.posRuleSetCount = posRuleSetCount = view.getUshort();
        coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
        if (posRuleSetCount > 0) {
          posRuleSets = Array(posRuleSetCount);
          for (i = _i = 0, _ref = posRuleSetCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            view.seek(offset + 6 + i * 2);
            posRuleSetOffset = view.getUshort();
            posRuleSet = PosRuleSet.createFromTTFDataView(view, offset);
            posRuleSets[i] = posRuleSet;
          }
          contextPositioning.posRuleSets = posRuleSets;
        }
      }
      if (posFormat === 2) {
        coverageOffset = view.getUshort();
        classDefOffset = view.getUshort();
        contextPositioning.posClassSetCount = posClassSetCount = view.getUshort();
        coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
        classDef = ClassDefinitionTable.createFromTTFDataView(view, offset + classDefOffset);
        if (posClassSetCount > 0) {
          posClassSets = Array(posClassSetCount);
          for (i = _j = 0, _ref1 = posClassSetCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            view.seek(offset + 8 + i * 2);
            posClassSetOffset = view.getUshort();
            posClassSet = PosClassSet.createFromTTFDataView(view, offset + posClassSetOffset);
            posClassSets[i] = posClassSet;
          }
          contextPositioning.posClassSets = posClassSets;
        }
      }
      return contextPositioning;
    };

    return ContextPositioning;

  })();

  PosRuleSet = (function() {

    function PosRuleSet() {}

    PosRuleSet.createFromTTFDataView = function(view, offset) {
      var i, posRule, posRuleCount, posRuleOffset, posRuleSet, posRules, _i, _ref;
      view.seek(offset);
      posRuleSet = new PosRuleSet();
      posRuleSet.posRuleCount = posRuleCount = view.getUshort();
      if (posRuleCount > 0) {
        posRules = Array(posRuleCount);
        for (i = _i = 0, _ref = posRuleCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          posRuleOffset = view.getUshort();
          posRule = PosRule.createFromTTFDataView(view, offset);
          posRules[i] = posRule;
        }
        posRuleSet.posRules = posRules;
      }
      return posRuleSet;
    };

    return PosRuleSet;

  })();

  PosRule = (function() {

    function PosRule() {}

    PosRule.createFromTTFDataView = function(view, offset) {
      var glyphCount, i, input, inputs, lookupIndex, posCount, posLookupRecord, posLookupRecords, posRule, sequenceIndex, _i, _j, _ref, _ref1;
      view.seek(offset);
      posRule = new PosRule.createFromTTFDataview(view, offset);
      posRule.glyphCount = glyphCount = view.getUshort();
      posRule.posCount = posCount = view.getUshort();
      if (glyphCount - 1 > 0) {
        inputs = Array(glyphCount - 1);
        for (i = _i = 0, _ref = glyphCount - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          input = view.getUshort();
          inputs[i] = input;
        }
        posRule.inputs = inputs;
      }
      if (posCount > 0) {
        posLookupRecords = Array(posCount);
        for (i = _j = 0, _ref1 = posCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          sequenceIndex = view.getUshort();
          lookupIndex = view.getUshort();
          posLookupRecord = {
            sequenceIndex: sequenceIndex,
            lookupIndex: lookupIndex
          };
          posLookupRecords[i] = posLookupRecord;
        }
        posRule.posLookupRecords = posLookupRecords;
      }
      return posRule;
    };

    return PosRule;

  })();

  PosClassSet = (function() {

    function PosClassSet() {}

    PosClassSet.createFromTTFDataView = function(view, offset) {
      var i, posClassRule, posClassRuleCount, posClassRuleOffset, posClassRules, posClassSet, _i, _ref;
      view.seek(offset);
      posClassSet = new PosClassSet();
      posClassSet.posClassRuleCount = posClassRuleCount = view.getUshort();
      if (posClassRuleCount > 0) {
        posClassRules = Array(posClassRuleCount);
        for (i = _i = 0, _ref = posClassRuleCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          posClassRuleOffset = view.getUshort();
          posClassRule = PosClassRule.createFromTTFDataView(view, offset + posClassRuleOffset);
          posClassRules[i] = posClassRule;
        }
        posClassSet.posClassRules = posClassRules;
      }
      return posClassSet;
    };

    return PosClassSet;

  })();

  PosClassRule = (function() {

    function PosClassRule() {}

    PosClassRule.createFromTTFDataView = function(view, offset) {
      var glyphCount, i, lookupIndex, posClass, posClassRule, posClasses, posCount, posLookupRecord, posLookupRecords, sequenceIndex, _i, _j, _ref, _ref1;
      view.seek(offset);
      posClassRule = new PosClassRule();
      posClassRule.glyphCount = glyphCount = view.getUshort();
      posClassRule.posCount = posCount = view.getUshort();
      if (glyphCount - 1 > 0) {
        posClasses = Array(glyphCount - 1);
        for (i = _i = 0, _ref = glyphCount - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          posClass = view.getUshort();
          posClasses = posClass;
        }
        posClassRule.posClasses = posClasses;
      }
      if (posCount > 0) {
        posLookupRecords = Array(posCount);
        for (i = _j = 0, _ref1 = posCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          sequenceIndex = view.getUshort();
          lookupIndex = view.getUshort();
          posLookupRecord = {
            sequenceIndex: sequenceIndex,
            lookupIndex: lookupIndex
          };
          posLookupRecords[i] = posLookupRecord;
        }
        posClassRule.posLookupRecords = posLookupRecords;
      }
      return posClassRule;
    };

    return PosClassRule;

  })();

  ChainContextPositioning = (function() {

    function ChainContextPositioning() {}

    ChainContextPositioning.createFromTTFDataView = function(view, offset) {
      var backtrackClassDefOffset, chainContextPositioning, chainPosClassSet, chainPosClassSetOffset, chainPosClassSetcount, chainPosClassSets, chainPosRule, chainPosRuleCount, chainPosRuleOffset, chainPosRuleSet, chainPosRuleSetCount, chainPosRuleSetOffset, chainPosRuleSets, chainPosRules, coverage, coverageOffset, i, inputClassDefOffset, j, lookAheadClassDefOffset, posFormat, _i, _j, _k, _ref, _ref1, _ref2;
      view.seek(offset);
      chainContextPositioning = new ChainContextPositioning();
      chainContextPositioning.posFormat = posFormat = view.getUshort();
      if (posFormat === 1) {
        coverageOffset = view.getUshort();
        chainContextPositioning.chainPosRuleSetCount = chainPosRuleSetCount = view.getUshort();
        coverage = CoverageTable.createFromTTFDataView(view, coverageOffset);
        if (chainPosRuleSetCount > 0) {
          chainPosRuleSets = Array(chainPosRuleSetCount);
          for (i = _i = 0, _ref = chainPosRuleSetCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            view.seek(offset + 6 + i * 2);
            chainPosRuleSetOffset = view.getUshort();
            view.seek(offset + chainPosRuleSetOffset);
            chainPosRuleCount = view.getUshort();
            if (chainPosRuleCount > 0) {
              chainPosRules = Array(chainPosRuleCount);
              for (j = _j = 0, _ref1 = chainPosRuleCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                view.seek(offset + chainPosRuleSetOffset + 2 + j * 2);
                chainPosRuleOffset = view.getUshort();
                chainPosRule = ChainPosRule.createFromTTFDataView(view, offset + chainPosRuleOffset);
                chainPosRules[j] = chainPosRule;
              }
            }
            chainPosRuleSet = {
              chainPosRuleCount: chainPosRuleCount,
              chainPosRules: chainePosRules
            };
            chainPosRuleSets[i] = chainPosRuleSet;
          }
          chainContextPositioning.chainPosRuleSets = chainPosRuleSets;
        }
        if (posFormat === 2) {
          coverageOffset = view.getUshort();
          backtrackClassDefOffset = view.getUshort();
          inputClassDefOffset = view.getUshort();
          lookAheadClassDefOffset = view.getUshort();
          chainContextPositioning.chainPosClassSetCount = chainPosClassSetcount = view.getUshort();
          if (chainPosClassSetcount > 0) {
            chainPosClassSets = [];
            for (i = _k = 0, _ref2 = chainPosClassSetcount - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
              view.seek(offset + 12 + i * 2);
              chainPosClassSetOffset = view.getUshort();
              chainPosClassSet = ChainPosClassSet.createFromTTFDataView(view, offset + chainPosClassSetOffset);
            }
          }
          chainContextPositioning.coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
          chainContextPositioning.backtrackClassDef = ClassDefinitionTable(view, offset + backtrackClassDefOffset);
          chainContextPositioning.inputClassDef = ClassDefinitionTable(view, offset + inputClassDefOffset);
        }
      }
      return chainContextPositioning;
    };

    return ChainContextPositioning;

  })();

  ChainPosRule = (function() {

    function ChainPosRule() {}

    ChainPosRule.createFromTTFDataView = function(view, offset) {
      var backtrack, backtrackGlyphCount, backtracks, chainPosRule, i, input, inputGlyphCount, inputs, lookAhead, lookAheadGlyphCount, lookAheads, lookupIndex, posCount, posLookupRecord, posLookupRecords, sequenceIndex, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      view.seek(offset);
      chainPosRule = new ChainPosRule();
      chainPosRule.backtrackGlyphCount = backtrackGlyphCount = view.getUshort();
      if (backtrackGlyphCount > 0) {
        backtracks = Array(backtrackGlyphCount);
        for (i = _i = 0, _ref = backtrackGlyphCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          backtrack = view.getUshort();
          backtracks[i] = backtrack;
        }
        chainPosRule.backtracks = backtracks;
      }
      chainPosRule.inputGlyphCount = inputGlyphCount = view.getUshort();
      if (inputGlyphCount - 1 > 0) {
        inputs = Array(inputGlyphCount - 1);
        for (i = _j = 0, _ref1 = inputGlyphCount - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          input = view.getUshort();
          inputs[i] = input;
        }
        chainPosRule.inputs = inputs;
      }
      chainPosRule.lookAheadGlyphCount = lookAheadGlyphCount = view.getUshort();
      if (lookAheadGlyphCount > 0) {
        lookAheads = Array(lookAheadGlyphCount);
        for (i = _k = 0, _ref2 = lookAheadGlyphCount - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          lookAhead = view.getUshort();
          lookAheads[i] = lookAhead;
        }
        chainPosRule.lookAheads = lookAheads;
      }
      chainPosRule.posCount = posCount = view.getUshort();
      if (posCount > 0) {
        posLookupRecords = Array(posCount);
        for (i = _l = 0, _ref3 = posCount - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
          sequenceIndex = view.getUshort();
          lookupIndex = view.getUshort();
          posLookupRecord = {
            sequenceIndex: sequenceIndex,
            lookupIndex: lookupIndex
          };
          posLookupRecords[i] = posLookupRecord;
        }
        chainPosRule.posLookupRecords = posLookupRecords;
      }
      return chainPosRule;
    };

    return ChainPosRule;

  })();

  ChainPosClassSet = (function() {

    function ChainPosClassSet() {}

    ChainPosClassSet.createFromTTFDataView = function(view, offset) {
      var chainPosClassRule, chainPosClassRuleCount, chainPosClassRuleOffset, chainPosClassRules, chainPosClassSet, i, _i, _ref;
      view.seek(offset);
      chainPosClassSet = new ChainPosClassSet();
      chainPosClassRuleCount = view.getUshort();
      if (chainPosClassRuleCount > 0) {
        chainPosClassRules = Array(chainPosClassRuleCount);
        for (i = _i = 0, _ref = chainPosClassRuleCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + 2 * i);
          chainPosClassRuleOffset = view.getUshort();
          chainPosClassRule = ChainPosClassRule.createFromTTFDataView(view, offset + chainPosClassRuleOffset);
          chainPosClassRules[i] = chainPosClassRule;
        }
        chainPosClassSet.chainPosClassRules = chainPosClassRules;
      }
      return chainPosClassSet;
    };

    return ChainPosClassSet;

  })();

  ChainPosClassRule = (function() {

    function ChainPosClassRule() {}

    ChainPosClassRule.createFromTTFDataView = function(view, offset) {
      var backtrack, backtrackGlyphCount, backtracks, chainPosClassRule, i, input, inputGlyphCount, inputs, lookAhead, lookAheadGlyphCount, lookAheads, lookupIndex, posCount, posLookupRecord, posLookupRecords, sequenceIndex, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      view.seek(offset);
      chainPosClassRule = new ChainPosClassRule();
      chainPosClassRule.backtrackGlyphCount = backtrackGlyphCount = view.getUshort();
      if (backtrackGlyphCount > 0) {
        backtracks = Array(backtrackGlyphCount);
        for (i = _i = 0, _ref = backtrackGlyphCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          backtrack = view.getUshort();
          backtracks[i] = backtrack;
        }
        chainPosClassRule.backtracks = backtracks;
      }
      chainPosClassRule.inputGlyphCount = inputGlyphCount = view.getUshort();
      if (inputGlyphCount - 1 > 0) {
        inputs = Array(inputGlyphCount - 1);
        for (i = _j = 0, _ref1 = inputGlyphCount - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          input = view.getUshort();
          inputs[i] = input;
        }
        chainPosClassRule.inputs = inputs;
      }
      chainPosClassRule.lookAheadGlyphCount = lookAheadGlyphCount = view.getUshort();
      if (lookAheadGlyphCount > 0) {
        lookAheads = Array(lookAheadGlyphCount);
        for (i = _k = 0, _ref2 = lookAheadGlyphCount - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          lookAhead = view.getUshort();
          lookAheads[i] = lookAhead;
        }
        chainPosClassRule.lookAheads = lookAheads;
      }
      chainPosClassRule.posCount = posCount = view.getUshort();
      if (posCount > 0) {
        posLookupRecords = Array(posCount);
        for (i = _l = 0, _ref3 = posCount - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
          sequenceIndex = view.getUshort();
          lookupIndex = view.getUshort();
          posLookupRecord = {
            sequenceIndex: sequenceIndex,
            lookupIndex: lookupIndex
          };
          posLookupRecords[i] = posLookupRecord;
        }
        chainPosClassRule.posLookupRecords = posLookupRecords;
      }
      return chainPosClassRule;
    };

    return ChainPosClassRule;

  })();

  ExtensionPositioning = (function() {

    function ExtensionPositioning() {}

    ExtensionPositioning.createFromTTFDataView = function(view, offset) {
      var extension, extensionLookupType, extensionOffset, extensionPositioning;
      view.seek(offset);
      extensionPositioning = new ExtensionPositioning();
      extensionPositioning.posFormat = view.getUshort();
      extensionPositioning.extensionLookupType = extensionLookupType = view.getUshort();
      extensionOffset = view.getUlong();
      extension = Lookup.createFromTTFDataView(view, offset + extensionOffset, "GPOS", extensionLookupType);
      extensionPositioning.extension = extension;
      return extensionPositioning;
    };

    return ExtensionPositioning;

  })();

  AnchorTable = (function() {

    function AnchorTable() {
      this.anchorFormat = null;
    }

    AnchorTable.createFromTTFDataView = function(view, offset) {
      var anchorFormat, anchorTable, xDeviceTableOffset, yDeviceTableOffset;
      view.seek(offset);
      anchorTable = new AnchorTable();
      anchorTable.anchorFormat = anchorFormat = view.getUshort();
      anchorTable.xCoordinate = view.getShort();
      anchorTable.yCoordinate = view.getShort();
      if (anchorFormat === 2) {
        anchorTable.anchorPoint = view.getUshort();
      }
      if (anchorFormat === 3) {
        xDeviceTableOffset = view.getUshort();
        yDeviceTableOffset = view.getUshort();
        anchorTable.xDeviceTable = DeviceTable.createFromTTFDataView(view, offset + xDeviceTableOffset);
        anchorTable.yDeviceTable = DeviceTable.createFromTTFDataView(view, offset + yDeviceTableOffset);
      }
      return anchorTable;
    };

    return AnchorTable;

  })();

  MarkArray = (function() {

    function MarkArray() {
      this.markCount = 0;
    }

    MarkArray.createFromTTFDataView = function(view, offset) {
      var i, markAnchor, markAnchorOffset, markArray, markClass, markCount, markRecords, _i, _ref;
      view.seek(offset);
      markArray = new MarkArray();
      markArray.markCount = markCount = view.getUshort();
      if (markCount > 0) {
        markRecords = Array(markCount);
        for (i = _i = 0, _ref = markCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 4);
          markClass = view.getUshort();
          markAnchorOffset = view.getUshort();
          markAnchor = AnchorTable.createFromTTFDataView(view, offset + markAnchorOffset);
          markRecords[i] = {
            markClass: markClass,
            markAnchor: markAnchor
          };
        }
        markArray.markRecords = markRecords;
      }
      return markArray;
    };

    return MarkArray;

  })();

  BaseArray = (function() {

    function BaseArray() {
      this.baseCount = 0;
    }

    BaseArray.createFromTTFDataView = function(view, offset) {
      var baseAnchor, baseAnchorOffset, baseArray, baseCount, baseRecord, baseRecords, i, _i, _ref;
      view.seek(offset);
      baseArray = new BaseArray();
      baseArray.baseCount = baseCount = view.getUshort();
      if (baseCount > 0) {
        baseRecords = Array(baseCount);
        for (i = _i = 0, _ref = baseCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          view.seek(offset + 2 + i * 2);
          baseAnchorOffset = view.getUshort();
          baseAnchor = AnchorTable.createFromTTFDataView(view, offset + baseAnchorOffset);
          baseRecord = {
            baseAnchor: baseAnchor
          };
          baseRecords[i] = baseRecord;
        }
      }
      baseArray.baseRecords = baseRecords;
      return baseArray;
    };

    return BaseArray;

  })();

  ValueRecord = (function() {

    function ValueRecord() {}

    ValueRecord.createFromTTFDataView = function(view, offset, valueFormat) {
      var valueRecord, xAdvDeviceOffset, xPlaDeviceOffset, yAdvDeviceOffset, yPlaDeviceOffset;
      view.seek(offset);
      valueRecord = new ValueRecord();
      if (valueFormat & 0x0001) {
        valueRecord.xPlacement = view.getShort();
      }
      if (valueFormat & 0x0002) {
        valueRecord.yPlacement = view.getShort();
      }
      if (valueFormat & 0x0004) {
        valueRecord.xAdvance = view.getShort();
      }
      if (valueFormat & 0x0008) {
        valueRecord.yAdvance = view.getShort();
      }
      if (valueFormat & 0x0010) {
        xPlaDeviceOffset = view.getUshort();
        if (xPlaDeviceOffset !== null && xPlaDeviceOffset !== 'undefined') {
          valueRecord.xPlaDevice = DeviceTable.createFromTTFDataView(view, offset + xPlaDeviceOffset);
        }
      }
      if (valueFormat & 0x0020) {
        yPlaDeviceOffset = view.getUshort();
        if (yPlaDeviceOffset !== null && yPlaDeviceOffset !== 'undefined') {
          valueRecord.yPlaDevice = DeviceTable.createFromTTFDataView(view, offset + yPlaDeviceOffset);
        }
      }
      if (valueFormat & 0x0040) {
        xAdvDeviceOffset = view.getUshort();
        if (xAdvDeviceOffset !== null && xAdvDeviceOffset !== 'undefined') {
          valueRecord.xAdvDevice = DeviceTable.createFromTTFDataView(view, offset + xAdvDeviceOffset);
        }
      }
      if (valueFormat & 0x0080) {
        yAdvDeviceOffset = view.getUshort();
        if (yAdvDeviceOffset !== null && yAdvDeviceOffset !== 'undefined') {
          valueRecord.yAdvDevice = DeviceTable.createFromTTFDataView(view, offset + yAdvDeviceOffset);
        }
      }
      return valueRecord;
    };

    return ValueRecord;

  })();

  CoverageTable = (function() {

    function CoverageTable() {
      this.coverageFormat = 0;
    }

    CoverageTable.createFromTTFDataView = function(view, offset) {
      var coverageFormat, coverageTable, end, glyphArray, glyphCount, glyphId, i, rangeCount, rangeRecord, start, startCoverageIndex, _i, _j, _ref, _ref1;
      view.seek(offset);
      coverageTable = new CoverageTable();
      coverageTable.coverageFormat = coverageFormat = view.getUshort();
      if (coverageFormat === 1) {
        coverageTable.glyphCount = glyphCount = view.getUshort();
        if (glyphCount > 0) {
          glyphArray = Array(glyphCount);
          for (i = _i = 0, _ref = glyphCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            glyphId = view.getUshort();
            glyphArray[i] = glyphId;
          }
          coverageTable.glyphArray = glyphArray;
        }
      }
      if (coverageFormat === 2) {
        rangeCount = view.getUshort();
        if (rangeCount > 0) {
          rangeRecord = Array(rangeCount);
          for (i = _j = 0, _ref1 = rangeCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            start = view.getUshort();
            end = view.getUshort();
            startCoverageIndex = view.getUshort();
            rangeRecord[i] = {
              start: start,
              end: end,
              startCoverageIndex: startCoverageIndex
            };
          }
          coverageTable.rangeRecord = rangeRecord;
        }
      }
      return coverageTable;
    };

    CoverageTable.createFromJSON = function(json) {
      var coverageFormat, coverageTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      coverageTable = new CoverageTable();
      coverageTable.coverageFormat = coverageFormat = json.coverageFormat;
      if (coverageFormat === 1) {
        coverageTable.glyphArray = json.glyphArray;
      }
      if (coverageFormat === 2) {
        coverageTable.rangeRecord = json.rangeRecord;
      }
      return coverageTable;
    };

    return CoverageTable;

  })();

  ClassDefinitionTable = (function() {

    function ClassDefinitionTable() {
      this.classFormat = 0;
    }

    ClassDefinitionTable.createFromTTFDataView = function(view, offset) {
      var classDefTable, classFormat, classId, classRangeCount, classRangeRecords, classValueArray, end, glyphCount, i, j, start, startGlyph, _i, _j, _k, _ref, _ref1, _ref2;
      view.seek(offset);
      classDefTable = new ClassDefinitionTable();
      classDefTable.classFormat = classFormat = view.getUshort();
      if (classFormat === 1) {
        startGlyph = view.getUshort();
        glyphCount = view.getUshort();
        if (glyphCount > 0) {
          classValueArray = Array(glyphCount);
          for (i = _i = 0, _ref = glyphCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            classId = view.getUshort();
            classValueArray[i] = {
              gId: startGlyph + i,
              "class": classId
            };
          }
          classDefTable.classValueArray = classValueArray;
        }
      }
      if (classFormat === 2) {
        classRangeCount = view.getUshort();
        classRangeRecords = [];
        if (classRangeCount > 0) {
          for (i = _j = 0, _ref1 = classRangeCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            start = view.getUshort();
            end = view.getUshort();
            classId = view.getUshort();
            classValueArray = Array(end - start + 1);
            for (j = _k = 0, _ref2 = end - start + 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
              classValueArray[j] = {
                gId: start + j,
                "class": classId
              };
            }
          }
          classDefTable.classValueArray = classValueArray;
        }
      }
      return classDefTable;
    };

    ClassDefinitionTable.createFromJSON = function(json) {
      var classDefTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      classDefTable = new ClassDefinitionTable();
      classDefTable.classFormat = json.classFormat;
      classDefTable.classValueArray = json.classValueArray;
      return classDefTable;
    };

    return ClassDefinitionTable;

  })();

  DeviceTable = (function() {

    function DeviceTable() {
      this.startSize = null;
      this.endSize = null;
      this.deltaFormt = 0;
      this.deltaValue = [];
    }

    DeviceTable.createFromTTFDataView = function(view, offset) {
      var deviceTable;
      deviceTable = new DeviceTable();
      deviceTable.startSize = view.getUshort();
      deviceTable.endSize = view.getUshort();
      deviceTable.deltaFormat = view.getUshort();
      return deviceTable;
    };

    DeviceTable.createFromJSON = function(json) {
      var deviceTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      deviceTable = new DeviceTable();
      devicaTable.startSize = json.startSize;
      devicaTable.endSize = json.endSize;
      return deviceTable.deltaFormat = json.deltaFormat;
    };

    return DeviceTable;

  })();



  GDEFTable = (function() {

    function GDEFTable() {
      var version;
      version = 0;
    }

    GDEFTable.createFromTTFDataView = function(view, offset) {
      var GDEF, attachListOffset, glyphClassDefOffset, ligCaretListOffset, markAttachClassDefListOffset, markGlyphSetsDefOffset, version;
      view.seek(offset);
      GDEF = {};
      GDEF.version = version = view.getUlong();
      if (version !== 0x00010000 && version !== 0x00010002) {
        console.log('invalid version GDEF');
      }
      glyphClassDefOffset = view.getUshort();
      attachListOffset = view.getUshort();
      ligCaretListOffset = view.getUshort();
      markAttachClassDefListOffset = view.getUshort();
      if (version === 0x00010002) {
        markGlyphSetsDefOffset = view.getUshort();
      }
      if (glyphClassDefOffset) {
        GDEF.glyphClassDef = ClassDefinitionTable.createFromTTFDataView(view, offset + glyphClassDefOffset);
      }
      if (attachListOffset) {
        GDEF.attachList = AttachmentListTable.createFromTTFDataView(view, offset + attachListOffset);
      }
      if (ligCaretListOffset) {
        GDEF.ligCaretList = LigCaretListTable.createFromTTFDataView(view, offset + ligCaretListOffset);
      }
      if (markAttachClassDefListOffset) {
        GDEF.markAttachClassDefList = ClassDefinitionTable.createFromTTFDataView(view, offset + markAttachClassDefListOffset);
      }
      if (markGlyphSetsDefOffset) {
        GDEF.markGlyphSetsDef = MarkGlyphSetsDef.createFromTTFDataView(view, offset + markGlyphSetsDefOffset);
      }
      return GDEF;
    };

    GDEFTable.createFromJSON = function(json) {
      var GDEF;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      GDEF = new GDEFTable();
      GDEF.version = json.version;
      if (json.glyphClassDef !== void 0) {
        GDEF.glyphClassDef = ClassDefinitionTable.createFromJSON(json.glyphClassDef);
      }
      if (json.attachList !== void 0) {
        GDEF.attachList = AttachmentListTable.createFromJSON(json.attachList);
      }
      if (json.ligCaretList !== void 0) {
        GDEF.ligCaretList = LigCaretListTable.createFromJSON(json.ligCaretList);
      }
      if (json.markAttachClassDefList !== void 0) {
        GDEF.markAttachClassDefList = ClassDefinitionTable.createFromJSON(json.markAttachClassDefList);
      }
      if (json.markGlyphSetsDef !== void 0) {
        GDEF.markGlyphSetsDef = MarkGlyphSetsDef.createFromJSON(json.markGlyphSetsDef);
      }
      return GDEF;
    };

    return GDEFTable;

  })();

  AttachmentListTable = (function() {

    function AttachmentListTable() {
      this.glyphCount = 0;
    }

    AttachmentListTable.createFromTTFDataView = function(view, offset) {
      var attachPointOffset, attachmentListTable, coverageOffset, glyphCount;
      view.seek(offset);
      attachmentListTable = new AttachmentListTable();
      coverageOffset = view.getUshort();
      attachmentListTable.coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
      view.seek(offset + 2);
      attachmentListTable.glyphCount = glyphCount = view.getUshort();
      attachPointOffset = view.getUshort();
      return attachmentListTable;
    };

    AttachmentListTable.createFromJSON = function(json) {
      var attachmentListTable;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      attachmentListTable = new AttachmentListTable();
      attachmentListTable.glyphCount = json.glyphCount;
      attachmentListTable.coverage = CoverageTable.createFromJSON(json.coverage);
      return attachmentListTable;
    };

    return AttachmentListTable;

  })();

  LigCaretListTable = (function() {

    function LigCaretListTable() {
      this.ligGlyphCount = 0;
    }

    LigCaretListTable.createFromTTFDataView = function(view, offset) {
      var caretCount, caretValue, caretValueOffset, coverage, coverageOffset, i, ligCaretList, ligGlyph, ligGlyphCount, _i;
      view.seek(offset);
      ligCaretList = new LigCaretListTable();
      coverageOffset = view.getUshort();
      coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
      view.seek(offset + 2);
      ligCaretList.coverage = coverage;
      ligCaretList.ligGlyphCount = ligGlyphCount = view.getUshort();
      if (ligGlyphCount > 0) {
        ligGlyph = Array(ligGlyphCount);
        for (i = _i = 0; 0 <= ligGlyphCount ? _i <= ligGlyphCount : _i >= ligGlyphCount; i = 0 <= ligGlyphCount ? ++_i : --_i) {
          caretCount = view.getUshort();
          caretValueOffset = view.getUshort();
          caretValue = CaretValueTable.createFromTTFDataView(view, offset + caretValueOffset);
          ligGlyph[i] = {
            caretCount: caretCount
          };
        }
        ligCareList.ligGlyph = ligGlyph;
      }
      return ligCaretList;
    };

    LigCaretListTable.createFromJSON = function(json) {
      var ligCaretList;
      if (typeof json === 'string') {
        json = JSON(parse(json));
      }
      ligCaretList = new LigCareListTable();
      ligCareList.coverage = CoverageTable.createFromJSON(json.coverage);
      return ligCaretList;
    };

    return LigCaretListTable;

  })();

  CaretValueTable = (function() {

    function CaretValueTable() {
      this.format = 0;
    }

    CaretValueTable.createFromTTFDataView = function(view, offset) {
      var caretValueTable, deviceTableOffset, format;
      view.seek(offset);
      caretValueTable = new CaretValueTable();
      caretValueTable.format = format = view.getUshort();
      switch (format) {
        case 1:
          caretValueTable.coordinate = view.getShort();
          break;
        case 2:
          caretValueTable.caretValuePoint = view.getUshort();
          break;
        case 3:
          caretValueTable.coordinate = view.getShort();
          deviceTableOffset = view.getShort();
          caretValueTable.deviceTable = DeviceTable.createFromTTFDataView(view, offset + deviceTableOffset);
      }
      return caretValueTable;
    };

    CaretValueTable.createFromJSON = function(json) {
      var caretValueTable, format;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      caretValueTable = new CaretValueTabel();
      caretValueTable.format = format = json.format;
      switch (format) {
        case 1:
          caretValueTable.coordinate = json.coordinate;
          break;
        case 2:
          caretvalueTable.caretValuePoint = json.caretValuePoint;
          break;
        case 3:
          caretValueTable.coordinate = json.coordinate;
          caretValueTable.deviceTable = DeviceTable.createFromJSON(json.devicetable);
      }
      return caretValueTable;
    };

    return CaretValueTable;

  })();

  MarkGlyphSetsDef = (function() {

    function MarkGlyphSetsDef() {
      this.format = 0;
    }

    MarkGlyphSetsDef.createFromTTFView = function(view, offset) {
      var coverage, coverageOffset, coverages, format, i, markGlyphSetsDef, markSetCount, _i, _ref;
      markGlyphSetsDef = new MarkGlyphSetsDef();
      markGlyphSetsDef.format = format = view.getUshort();
      markGlyphSetsDef.markSetCount = markSetCount = view.getUshort();
      if (markSetCount > 0) {
        coverages = Array(markSetCount);
        for (i = _i = 0, _ref = markSetCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          coverageOffset = view.getUlong();
          coverage = CoverageTable.createFromTTFDataView(view, offset + coverageOffset);
          coverages[i] = coverage;
          view.seek(offset + 4 + i * 4);
        }
        markGlyphSetsDef.coverages = coverages;
      }
      return markGlyphSetsDef;
    };

    MarkGlyphSetsDef.createFromJSON = function(json) {
      var coverage, coverages, i, markGlyphSetsDef, markSetCount, _i, _ref;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      markGlyphSetsDef = new MarkGlyphSetsDef();
      markGlyphSetsDef.format = json.format;
      markGlyphSetsDef.markSetCount = markSetCount = json.markSetCount;
      if (markSetCount > 0) {
        coverages = Array(markSetCount);
        for (i = _i = 0, _ref = markSetCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          coverage = CoverageTable.createFromJSON(json.coverages[i]);
          coverages[i] = coverage;
        }
      }
      markGlyphSetsDef.coverages = coverages;
      return markGlyphSetsDef;
    };

    return MarkGlyphSetsDef;

  })();



  GlyfTable = (function() {

    function GlyfTable() {
      this.glyphs = [];
    }

    GlyfTable.prototype.getGlyphById = function(id) {
      if (typeof this.glyphs[id] !== 'undefined') {
        return this.glyphs[id];
      } else {
        return false;
      }
    };

    GlyfTable.createFromTTFDataView = function(view, offset, ttf) {
      var glyfTable, glyphLocation, i, loca, location;
      loca = ttf.loca;
      view.seek(offset);
      glyfTable = new GlyfTable();
      glyfTable.glyphs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = loca.offsets.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          location = loca.offsets[i];
          glyphLocation = location + offset;
          if ((loca.offsets[i + 1] != null) && location === loca.offsets[i + 1]) {
            _results.push(new SimpleGlyphData(i, glyfTable));
          } else if (view.getShort(glyphLocation) >= 0) {
            _results.push(SimpleGlyphData.createFromTTFDataView(view, glyphLocation, i, glyfTable));
          } else {
            _results.push(CompositeGlyphData.createFromTTFDataView(view, glyphLocation, i, glyfTable));
          }
        }
        return _results;
      })();
      return glyfTable;
    };

    GlyfTable.createFromJSON = function(json) {
      var glyfTable, glyph, _i, _len, _ref;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      glyfTable = new GlyfTable();
      _ref = json.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glyph = _ref[_i];
        if (glyph.type === 'simple') {
          glyfTable.glyphs.push(SimpleGlyphData.createFromJSON(glyph, glyfTable));
        } else {
          glyfTable.glyphs.push(CompositeGlyphData.createFromJSON(glyph, glyfTable));
        }
      }
      return glyfTable;
    };

    return GlyfTable;

  })();



  GPOSTable = (function() {

    function GPOSTable() {
      this.version = 0;
    }

    GPOSTable.createFromTTFDataView = function(view, offset) {
      var GPOS, featureList, featureListOffset, lookupList, lookupListOffset, scriptList, scriptListOffset, version;
      view.seek(offset);
      GPOS = new GPOSTable();
      GPOS.version = version = view.getFixed();
      scriptListOffset = view.getUshort();
      featureListOffset = view.getUshort();
      lookupListOffset = view.getUshort();
      scriptList = ScriptListTable.createFromTTFDataView(view, offset + scriptListOffset);
      featureList = FeatureListTable.createFromTTFDataView(view, offset + featureListOffset);
      lookupList = LookupListTable.createFromTTFDataView(view, offset + lookupListOffset, "GPOS");
      GPOS.scriptList = scriptList;
      GPOS.featureList = featureList;
      GPOS.lookupList = lookupList;
      return GPOS;
    };

    GPOSTable.createFromJSON = function(json) {
      var GPOS;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      GPOS = new GPOSTable();
      GPOS.version = json.version;
      GPOS.scriptList = ScriptListTable.createFromJSON(json.scriptList);
      GPOS.featureList = FeatureListTable.createFromJSON(json.featureList);
      GPOS.lookupList = LookupListTable.createFromJSON(json.lookupList, "GPOS");
      return GPOS;
    };

    return GPOSTable;

  })();

  HeadTable = (function() {

    function HeadTable() {
      this.version = 0;
      this.fontRevision = 0;
      this.checkSumAdjustment = '0x00000000';
      this.magicNumber = '0x5f0f3cf5';
      this.flags = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.unitsPerEm = 0;
      this.created = new Date();
      this.modified = new Date();
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.macStyle = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.lowestRecPPEM = 0;
      this.fontDirectionHint = 2;
      this.indexToLocFormat = 0;
      this.glyphDataFormat = 0;
    }

    HeadTable.prototype.isLocaLong = function() {
      return this.indexToLocFormat === 1;
    };

    HeadTable.createFromTTFDataView = function(view, offset) {
      var head;
      view.seek(offset);
      head = new HeadTable();
      head.version = view.getFixed();
      head.fontRevision = view.getFixed();
      head.checkSumAdjustment = '0x' + view.getUlong(offset + 8).toString(16);
      head.magicNumber = '0x' + view.getUlong().toString(16);
      head.flags = view.getUshortFlags();
      head.unitsPerEm = view.getUshort();
      head.created = view.getLongDateTime();
      head.modified = view.getLongDateTime();
      head.xMin = view.getShort();
      head.yMin = view.getShort();
      head.xMax = view.getShort();
      head.yMax = view.getShort();
      head.macStyle = view.getUshortFlags();
      head.lowestRecPPEM = view.getUshort();
      head.fontDirectionHint = view.getShort();
      head.indexToLocFormat = view.getShort();
      head.glyphDataFormat = view.getShort();
      return head;
    };

    HeadTable.createFromJSON = function(json) {
      var head;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      head = new HeadTable();
      head.version = json.version;
      head.fontRevision = json.fontRevision;
      head.checkSumAdjustment = json.checkSumAdjustment;
      head.magicNumber = json.magicNumber;
      head.flags = json.flags;
      head.unitsPerEm = json.unitsPerEm;
      head.created = new Date(json.created);
      head.modified = new Date(json.modified);
      head.xMin = json.xMin;
      head.yMin = json.yMin;
      head.xMax = json.xMax;
      head.yMax = json.yMax;
      head.macStyle = json.macStyle;
      head.lowestRecPPEM = json.lowestRecPPEM;
      head.fontDirectionHint = json.fontDirectionHint;
      head.indexToLocFormat = json.indexToLocFormat;
      head.glyphDataFormat = json.glyphDataFormat;
      return head;
    };

    return HeadTable;

  })();


  HheaTable = (function() {

    function HheaTable() {
      this.version = 0;
      this.ascender = 0;
      this.descender = 0;
      this.lineGap = 0;
      this.advanceWidthMax = 0;
      this.minLeftSideBearing = 0;
      this.minRightSideBearing = 0;
      this.xMaxExtent = 0;
      this.caretSlopeRise = 0;
      this.caretSlopeRun = 0;
      this.caretOffset = 0;
      this.reserved_0 = 0;
      this.reserved_1 = 0;
      this.reserved_2 = 0;
      this.reserved_3 = 0;
      this.metricDataFormat = 0;
      this.numberOfHMetrics = 0;
    }

    HheaTable.createFromTTFDataView = function(view, offset, ttf) {
      var hhea;
      view.seek(offset);
      hhea = new HheaTable();
      hhea.version = view.getFixed();
      hhea.ascender = view.getFWord();
      hhea.descender = view.getFWord();
      hhea.lineGap = view.getFWord();
      hhea.advanceWidthMax = view.getUFWord();
      hhea.minLeftSideBearing = view.getFWord();
      hhea.minRightSideBearing = view.getFWord();
      hhea.xMaxExtent = view.getFWord();
      hhea.caretSlopeRise = view.getShort();
      hhea.caretSlopeRun = view.getShort();
      hhea.caretOffset = view.getShort();
      hhea.reserved_0 = view.getShort();
      hhea.reserved_1 = view.getShort();
      hhea.reserved_2 = view.getShort();
      hhea.reserved_3 = view.getShort();
      hhea.metricDataFormat = view.getShort();
      hhea.numberOfHMetrics = view.getUshort();
      return hhea;
    };

    HheaTable.createFromJSON = function(json) {
      var hhea;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      hhea = new HheaTable();
      hhea.version = json.version;
      hhea.ascender = json.ascender;
      hhea.descender = json.descender;
      hhea.lineGap = json.lineGap;
      hhea.advanceWidthMax = json.advanceWidthMax;
      hhea.minLeftSideBearing = json.minLeftSideBearing;
      hhea.minRightSideBearing = json.minRightSideBearing;
      hhea.xMaxExtent = json.xMaxExtent;
      hhea.caretSlopeRise = json.caretSlopeRise;
      hhea.caretSlopeRun = json.caretSlopeRun;
      hhea.caretOffset = json.caretOffset;
      hhea.reserved_0 = json.reserved_0;
      hhea.reserved_1 = json.reserved_1;
      hhea.reserved_2 = json.reserved_2;
      hhea.reserved_3 = json.reserved_3;
      hhea.metricDataFormat = json.metricDataFormat;
      hhea.numberOfHMetrics = json.numberOfHMetrics;
      return hhea;
    };

    return HheaTable;

  })();


  HmtxTable = (function() {

    function HmtxTable() {
      this.hMetrics = [];
      this.leftSideBearing = [];
    }

    HmtxTable.createFromTTFDataView = function(view, offset, ttf) {
      var hmtx, i, lsbNum, numGlyphs, numberOfHMetrics;
      numberOfHMetrics = ttf.hhea.numberOfHMetrics;
      numGlyphs = ttf.maxp.numGlyphs;
      lsbNum = numGlyphs - numberOfHMetrics;
      view.seek(offset);
      hmtx = new HmtxTable();
      hmtx.hMetrics = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= numberOfHMetrics ? _i <= numberOfHMetrics : _i >= numberOfHMetrics; i = 1 <= numberOfHMetrics ? ++_i : --_i) {
          _results.push({
            advanceWidth: view.getUshort(),
            lsb: view.getShort()
          });
        }
        return _results;
      })();
      if (lsbNum > 0) {
        hmtx.leftSideBearing = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 1; 1 <= lsbNum ? _i <= lsbNum : _i >= lsbNum; i = 1 <= lsbNum ? ++_i : --_i) {
            _results.push(view.getShort());
          }
          return _results;
        })();
      }
      return hmtx;
    };

    HmtxTable.createFromJSON = function(json) {
      var hmtx;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      hmtx = new HmtxTable();
      hmtx.hMetrics = json.hMetrics;
      hmtx.leftSideBearing = json.leftSideBearing;
      return hmtx;
    };

    return HmtxTable;

  })();


  LocaTable = (function() {

    function LocaTable() {
      this.offsets = [];
    }

    LocaTable.createFromTTFDataView = function(view, offset, ttf) {
      var i, loca, long, numGlyphs;
      numGlyphs = ttf.getNumGlyphs();
      long = ttf.isLocaLong();
      view.seek(offset);
      loca = new LocaTable();
      loca.offsets = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= numGlyphs ? _i <= numGlyphs : _i >= numGlyphs; i = 0 <= numGlyphs ? ++_i : --_i) {
          if (long) {
            _results.push(view.getUlong());
          } else {
            _results.push(view.getUshort() * 2);
          }
        }
        return _results;
      })();
      return loca;
    };

    LocaTable.createFromJSON = function(json) {
      var loca;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      loca = new LocaTable();
      loca.offsets = json.offsets;
      return loca;
    };

    return LocaTable;

  })();


  MaxpTable = (function() {

    function MaxpTable() {
      this.version = 0;
      this.numGlyphs = 0;
      this.maxPoints = 0;
      this.maxContours = 0;
      this.maxCompositPoints = 0;
      this.maxCompositContours = 0;
      this.maxZones = 0;
      this.maxTwilightPoints = 0;
      this.maxStorage = 0;
      this.maxFunctionDefs = 0;
      this.maxInstructionDefs = 0;
      this.maxStackElements = 0;
      this.maxSizeOfInstructions = 0;
      this.maxComponentElements = 0;
      this.maxComponentDepth = 0;
    }

    MaxpTable.createFromTTFDataView = function(view, offset) {
      var maxp;
      view.seek(offset);
      maxp = new MaxpTable();
      maxp.version = view.getFixed();
      maxp.numGlyphs = view.getUshort();
      maxp.maxPoints = view.getUshort();
      maxp.maxContours = view.getUshort();
      maxp.maxCompositPoints = view.getUshort();
      maxp.maxCompositContours = view.getUshort();
      maxp.maxZones = view.getUshort();
      maxp.maxTwilightPoints = view.getUshort();
      maxp.maxStorage = view.getUshort();
      maxp.maxFunctionDefs = view.getUshort();
      maxp.maxInstructionDefs = view.getUshort();
      maxp.maxStackElements = view.getUshort();
      maxp.maxSizeOfInstructions = view.getUshort();
      maxp.maxComponentElements = view.getUshort();
      maxp.maxComponentDepth = view.getUshort();
      return maxp;
    };

    MaxpTable.createFromJSON = function(json) {
      var maxp;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      maxp = new MaxpTable();
      maxp.version = json.version;
      maxp.numGlyphs = json.numGlyphs;
      maxp.maxPoints = json.maxPoints;
      maxp.maxContours = json.maxContours;
      maxp.maxCompositPoints = json.maxCompositPoints;
      maxp.maxCompositContours = json.maxCompositContours;
      maxp.maxZones = json.maxZones;
      maxp.maxTwilightPoints = json.maxTwilightPoints;
      maxp.maxStorage = json.maxStorage;
      maxp.maxFunctionDefs = json.maxFunctionDefs;
      maxp.maxInstructionDefs = json.maxInstructionDefs;
      maxp.maxStackElements = json.maxStackElements;
      maxp.maxSizeOfInstructions = json.maxSizeOfInstructions;
      maxp.maxComponentElements = json.maxComponentElements;
      maxp.maxComponentDepth = json.maxComponentDepth;
      return maxp;
    };

    return MaxpTable;

  })();


  NameTable = (function() {

    function NameTable() {
      this.format = 0;
      this.count = 0;
    }

    NameTable.createFromTTFDataView = function(view, offset, ttf) {
      var charCode, currentOffset, i, j, langTagCount, langTagRecords, length, name, nameRecord, nameRecords, recOffset, string, stringOffset, _i, _j, _k, _ref, _ref1, _ref2;
      view.seek(offset);
      name = new NameTable();
      name.format = view.getUshort();
      name.count = view.getUshort();
      stringOffset = view.getUshort();
      nameRecords = Array(name.count);
      for (i = _i = 0, _ref = name.count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        currentOffset = offset + 6 + i * 12;
        view.seek(currentOffset);
        nameRecord = {};
        nameRecord.platformId = view.getUshort();
        nameRecord.encodingId = view.getUshort();
        nameRecord.languageId = view.getUshort();
        nameRecord.nameId = view.getUshort();
        length = view.getUshort();
        recOffset = view.getUshort();
        if (nameRecord.platformId === 3 && ((_ref1 = nameRecord.encodingId) === 0 || _ref1 === 1 || _ref1 === 10)) {
          string = "";
          for (j = _j = 0, _ref2 = (length / 2) - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            charCode = view.getUshort(offset + stringOffset + recOffset + j * 2);
            string += String.fromCharCode(charCode);
          }
        } else {
          string = view.getString(length, offset + stringOffset + recOffset);
        }
        nameRecord.string = string;
        nameRecords[i] = nameRecord;
      }
      name.nameRecords = nameRecords;
      if (name.format === 1) {
        langTagCount = view.getUshort();
        langTagRecords = [];
        for (i = _k = 0; 0 <= langTagCount ? _k <= langTagCount : _k >= langTagCount; i = 0 <= langTagCount ? ++_k : --_k) {
          length = view.getUshort();
          recOffset = view.getUshort();
        }
      }
      return name;
    };

    NameTable.createFromJSON = function(json) {
      var name;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      name = new NameTable();
      name.format = json.format;
      name.nameRecords = json.nameRecords;
      return name;
    };

    return NameTable;

  })();

  OS_2Table = (function() {

    function OS_2Table() {
      this.version = 0;
      this.xAvgCharWidth = 0;
      this.usWeightClass = 400;
      this.usWidthClass = 5;
      this.fsType = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ySubscriptXSize = 0;
      this.ySubscriptYSize = 0;
      this.ySubscriptXOffset = 0;
      this.ySubscriptYOffset = 0;
      this.ySuperscriptXSize = 0;
      this.ySuperscriptYSize = 0;
      this.ySuperscriptXOffset = 0;
      this.ySuperscriptYOffset = 0;
      this.yStrikeoutSize = 0;
      this.yStrikeoutPosition = 0;
      this.sFamilyClass = {
        "class": 0,
        subclass: 0
      };
      this.panose = {
        bFamilyType: 0,
        bSerifStyle: 0,
        bWeight: 0,
        bProportion: 0,
        bContrast: 0,
        bStrokeVariation: 0,
        bArmStyle: 0,
        bLetterForm: 0,
        bMidline: 0,
        bXHeight: 0
      };
      this.ulUnicodeRange1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.achVendID = '';
      this.fsSelection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.usFirstCharIndex = 0;
      this.usLastCharIndex = 0;
      this.sTypoAscender = 0;
      this.sTypoDescender = 0;
      this.sTypoLineGap = 0;
      this.usWinAscent = 0;
      this.usWinDescent = 0;
      this.ulCodePageRange1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulCodePageRange2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.sxHeight = void 0;
      this.sCapHeight = void 0;
      this.usDefaultChar = void 0;
      this.usBreakChar = void 0;
      this.usMaxContext = void 0;
    }

    OS_2Table.prototype.getUsWeightClassString = function() {
      return OS_2Table.US_WEIGHT_CLASS[this.usWeightClass];
    };

    OS_2Table.prototype.getUsWidthClassString = function() {
      return OS_2Table.US_WIDTH_CLASS[this.usWidthClass];
    };

    OS_2Table.prototype.getFamilyClass = function() {
      if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]] !== 'undefined') {
        return OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].name;
      } else {
        return false;
      }
    };

    OS_2Table.prototype.getFamilySubclass = function() {
      if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]] !== 'undefined' && typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass !== 'undefined') {
        if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass[this.sFamilyClass.subclass] !== 'undefined') {
          return OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass[this.sFamilyClass.subclass];
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    OS_2Table.US_WEIGHT_CLASS = {
      100: 'Thin',
      200: 'Extra-light',
      300: 'Light',
      400: 'Normal',
      500: 'Medium',
      600: 'Semi-bold',
      700: 'Bold',
      800: 'Extra-bold',
      900: 'Black'
    };

    OS_2Table.US_WIDTH_CLASS = {
      1: 'Ultra-condensed',
      2: 'Extra-condensed',
      3: 'Condensed',
      4: 'Semi-condensed',
      5: 'Medium',
      6: 'Semi-expanded',
      7: 'Expanded',
      8: 'Extra-expanded',
      9: 'Ultra-expanded'
    };

    OS_2Table.IBM_FONT_CLASS = {
      0: {
        name: 'No Classification'
      },
      1: {
        name: 'Oldstyle Serifs',
        subclass: {
          0: 'No Classification',
          1: 'IBM Rounded Legibility',
          2: 'Garalde',
          3: 'Venetian',
          4: 'Modified Venetian',
          5: 'Dutch Modern',
          6: 'Dutch Traditional',
          7: 'Contemporary',
          8: 'Calligraphic',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      2: {
        name: 'Transitional Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Direct Line',
          2: 'Script',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      3: {
        name: 'Modern Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Italian',
          2: 'Script',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      4: {
        name: 'Clarendon Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Clarendon',
          2: 'Modern',
          3: 'Traditional',
          4: 'Newspaper',
          5: 'Stub Serif',
          6: 'Monotone',
          7: 'Typewriter',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      5: {
        name: 'Slab Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Monotone',
          2: 'Humanist',
          3: 'Geometric',
          4: 'Swiss',
          5: 'Typewriter',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      6: {
        name: '(reserved for future use)'
      },
      7: {
        name: 'Freeform Serifs',
        subclass: {
          0: 'No Classification',
          1: '(reserved for future use)',
          2: '(reserved for future use)',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      8: {
        name: 'Sans Serifs',
        subclass: {
          0: 'No Classification',
          1: 'IBM Neo-grotesque Gothic',
          2: 'Humanist',
          3: 'Low-x Round Geometric',
          4: 'High-x Round Geometric',
          5: 'Neo-grotesque Gothic',
          6: 'Modified Neo-grotesque Gothic',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: 'Typewriter Gothic',
          10: 'Matrix',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      9: {
        name: 'Ornamentals',
        subclass: {
          0: 'No Classification',
          1: 'Engraver',
          2: 'Black Letter',
          3: 'Decorative',
          4: 'Three Dimensional',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      10: {
        name: 'Scripts',
        subclass: {
          0: 'No Classification',
          1: 'Uncial',
          2: 'Brush Joined',
          3: 'Formal Joined',
          4: 'Monotone Joined',
          5: 'Calligraphic',
          6: 'Brush Unjoined',
          7: 'Formal Unjoined',
          8: 'Monotone Unjoined',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      11: {
        name: '(reserved for future use)'
      },
      12: {
        name: 'Symbolic',
        subclass: {
          0: 'No Classification',
          1: '(reserved for future use)',
          2: '(reserved for future use)',
          3: 'Mixed Serif',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: 'Oldstyle Serif',
          7: 'Neo-grotesque Sans Serif',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      13: {
        name: 'Reserved'
      },
      14: {
        name: 'Reserved'
      }
    };

    OS_2Table.PANOSE = {
      FAMILY_TYPE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Text and Display',
        3: 'Script',
        4: 'Decorative',
        5: 'Pictorial'
      },
      SERIF_STYLE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Cove',
        3: 'Obtuse Cove',
        4: 'Square Cove',
        5: 'Obtuse Square Cove',
        6: 'Square',
        7: 'Thin',
        8: 'Bone',
        9: 'Exaggerated',
        10: 'Triangle',
        11: 'Normal Sans',
        12: 'Obtuse Sans',
        13: 'Perp Sans',
        14: 'Flared',
        15: 'Rounded'
      },
      WEIGHT: {
        0: 'Any',
        1: 'No Fit',
        2: 'Very Light',
        3: 'Light',
        4: 'Thin',
        5: 'Book',
        6: 'Medium',
        7: 'Demi',
        8: 'Bold',
        9: 'Heavy',
        10: 'Black',
        11: 'Nord'
      },
      PROPORTION: {
        0: 'Any',
        1: 'No Fit',
        2: 'Old Style',
        3: 'Modern',
        4: 'Even Width',
        5: 'Expanded',
        6: 'Condensed',
        7: 'Very Expanded',
        8: 'Very Condensed',
        9: 'Monospaced'
      },
      CONTRAST: {
        0: 'Any',
        1: 'No Fit',
        2: 'None',
        3: 'Very Low',
        4: 'Low',
        5: 'Medium Low',
        6: 'Medium',
        7: 'Medium High',
        8: 'High',
        9: 'Very High'
      },
      STROKE_VARIATION: {
        0: 'Any',
        1: 'No Fit',
        2: 'Gradual/Diagonal',
        3: 'Gradual/Transitional',
        4: 'Gradual/Vertical',
        5: 'Gradual/Horizontal',
        6: 'Rapid/Vertical',
        7: 'Rapid/Horizontal',
        8: 'Instant/Vertical'
      },
      ARM_STYLE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Straight Arms/Horizontal',
        3: 'Straight Arms/Wedge',
        4: 'Straight Arms/Vertical',
        5: 'Straight Arms/Single Serif',
        6: 'Straight Arms/Double Serif',
        7: 'Non-Straight Arms/Horizontal',
        8: 'Non-Straight Arms/Wedge',
        9: 'Non-Straight Arms/Vertical',
        10: 'Non-Straight Arms/Single Serif',
        11: 'Non-Straight Arms/Double Serif'
      },
      LETTERFORM: {
        0: 'Any',
        1: 'No Fit',
        2: 'Normal/Contact',
        3: 'Normal/Weighted',
        4: 'Normal/Boxed',
        5: 'Normal/Flattened',
        6: 'Normal/Rounded',
        7: 'Normal/Off Center',
        8: 'Normal/Square',
        9: 'Oblique/Contact',
        10: 'Oblique/Weighted',
        11: 'Oblique/Boxed',
        12: 'Oblique/Flattened',
        13: 'Oblique/Rounded',
        14: 'Oblique/Off Center',
        15: 'Oblique/Square'
      },
      MIDLINE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Standard/Trimmed',
        3: 'Standard/Pointed',
        4: 'Standard/Serifed',
        5: 'High/Trimmed',
        6: 'High/Pointed',
        7: 'High/Serifed',
        8: 'Constant/Trimmed',
        9: 'Constant/Pointed',
        10: 'Constant/Serifed',
        11: 'Low/Trimmed',
        12: 'Low/Pointed',
        13: 'Low/Serifed'
      },
      X_HEIGHT: {
        0: 'Any',
        1: 'No Fit',
        2: 'Constant/Small',
        3: 'Constant/Standard',
        4: 'Constant/Large',
        5: 'Ducking/Small',
        6: 'Ducking/Standard',
        7: 'Ducking/Large'
      }
    };

    OS_2Table.UNICODE_RANGE = {
      0: 'Basic Latin',
      1: 'Latin-1 Supplement',
      2: 'Latin Extended-A',
      3: 'Latin Extended-B',
      4: 'IPA Extensions',
      5: 'Spacing Modifier Letters',
      6: 'Combining Diacritical Marks',
      7: 'Basic Greek',
      8: 'Greek Symbols and Coptic',
      9: 'Cyrillic',
      10: 'Armenian',
      11: 'Basic Hebrew',
      12: 'Hebrew Extended (A and B blocks combined)',
      13: 'Basic Arabic',
      14: 'Arabic Extended',
      15: 'Devanagari',
      16: 'Bengali',
      17: 'Gurmukhi',
      18: 'Gujarati',
      19: 'Oriya',
      20: 'Tamil',
      21: 'Telugu',
      22: 'Kannada',
      23: 'Malayalam',
      24: 'Thai',
      25: 'Lao',
      26: 'Basic Georgian',
      27: 'Georgian Extended',
      28: 'Hangul Jamo',
      29: 'Latin Extended Additional',
      30: 'Greek Extended',
      31: 'General Punctuation',
      32: 'Superscripts And Subscripts',
      33: 'Currency Symbols',
      34: 'Combining Diacritical Marks For Symbols',
      35: 'Letterlike Symbols',
      36: 'Number Forms',
      37: 'Arrows',
      38: 'Mathematical Operators',
      39: 'Miscellaneous Technical',
      40: 'Control Pictures',
      41: 'Optical Character Recognition',
      42: 'Enclosed Alphanumerics',
      43: 'Box Drawing',
      44: 'Block Elements',
      45: 'Geometric Shapes',
      46: 'Miscellaneous Symbols',
      47: 'Dingbats',
      48: 'CJK Symbols And Punctuation',
      49: 'Hiragana',
      50: 'Katakana',
      51: 'Bopomofo',
      52: 'Hangul Compatibility Jamo',
      53: 'CJK Miscellaneous',
      54: 'Enclosed CJK Letters And Months',
      55: 'CJK Compatibility',
      56: 'Hangul',
      57: 'Reserved for Unicode SubRanges',
      58: 'Reserved for Unicode SubRanges',
      59: 'CJK Unified Ideographs',
      60: 'Private Use Area',
      61: 'CJK Compatibility Ideographs',
      62: 'Alphabetic Presentation Forms',
      63: 'Arabic Presentation Forms-A',
      64: 'Combining Half Marks',
      65: 'CJK Compatibility Forms',
      66: 'Small Form Variants',
      67: 'Arabic Presentation Forms-B',
      68: 'Halfwidth And Fullwidth Forms',
      69: 'Specials'
    };

    OS_2Table.UL_CODE_PAGE_RANGE = {
      0: {
        codePage: 1252,
        description: 'Latin 1'
      },
      1: {
        codePage: 1250,
        description: 'Latin 2: Eastern Europe'
      },
      2: {
        codePage: 1251,
        description: 'Cyrillic'
      },
      3: {
        codePage: 1253,
        description: 'Greek'
      },
      4: {
        codePage: 1254,
        description: 'Turkish'
      },
      5: {
        codePage: 1255,
        description: 'Hebrew'
      },
      6: {
        codePage: 1256,
        description: 'Arabic'
      },
      7: {
        codePage: 1257,
        description: 'Windows Baltic'
      },
      16: {
        codePage: 874,
        description: 'Thai'
      },
      17: {
        codePage: 932,
        description: 'JIS/Japan'
      },
      18: {
        codePage: 936,
        description: 'Chinese: Simplified chars--PRC and Singapore'
      },
      19: {
        codePage: 949,
        description: 'Korean Wansung'
      },
      20: {
        codePage: 950,
        description: 'Chinese: Traditional chars--Taiwan and Hong Kong'
      },
      21: {
        codePage: 1361,
        description: 'Korean Johab'
      },
      29: {
        codePage: null,
        description: 'Macintosh Character Set (US Roman)'
      },
      30: {
        codePage: null,
        description: 'OEM Character Set'
      },
      31: {
        codePage: null,
        description: 'Symbol Character Set'
      },
      48: {
        codePage: 869,
        description: 'IBM Greek'
      },
      49: {
        codePage: 866,
        description: 'MS-DOS Russian'
      },
      50: {
        codePage: 865,
        description: 'MS-DOS Nordic'
      },
      51: {
        codePage: 864,
        description: 'Arabic'
      },
      52: {
        codePage: 863,
        description: 'MS-DOS Canadian French'
      },
      53: {
        codePage: 862,
        description: 'Hebrew'
      },
      54: {
        codePage: 861,
        description: 'MS-DOS Icelandic'
      },
      55: {
        codePage: 860,
        description: 'MS-DOS Portuguese'
      },
      56: {
        codePage: 857,
        description: 'IBM Turkish'
      },
      57: {
        codePage: 855,
        description: 'IBM Cyrillic; primarily Russian'
      },
      58: {
        codePage: 852,
        description: 'Latin 2'
      },
      59: {
        codePage: 775,
        description: 'MS-DOS Baltic'
      },
      60: {
        codePage: 737,
        description: 'Greek; former 437 G'
      },
      61: {
        codePage: 708,
        description: 'Arabic; ASMO 708'
      },
      62: {
        codePage: 850,
        description: 'WE/Latin 1'
      },
      63: {
        codePage: 437,
        description: 'US'
      }
    };

    OS_2Table.createFromTTFDataView = function(view, offset, ttf) {
      var OS2;
      view.seek(offset);
      OS2 = new OS_2Table();
      OS2.version = view.getUshort();
      OS2.xAvgCharWidth = view.getShort();
      OS2.usWeightClass = view.getUshort();
      OS2.usWidthClass = view.getUshort();
      OS2.fsType = view.getUshortFlags();
      OS2.ySubscriptXSize = view.getShort();
      OS2.ySubscriptYSize = view.getShort();
      OS2.ySubscriptXOffset = view.getShort();
      OS2.ySubscriptYOffset = view.getShort();
      OS2.ySuperscriptXSize = view.getShort();
      OS2.ySuperscriptYSize = view.getShort();
      OS2.ySuperscriptXOffset = view.getShort();
      OS2.ySuperscriptYOffset = view.getShort();
      OS2.yStrikeoutSize = view.getShort();
      OS2.yStrikeoutPosition = view.getShort();
      OS2.sFamilyClass["class"] = view.getByte();
      OS2.sFamilyClass.subclass = view.getByte();
      OS2.panose.bFamilyType = view.getByte();
      OS2.panose.bSerifStyle = view.getByte();
      OS2.panose.bWeight = view.getByte();
      OS2.panose.bProportion = view.getByte();
      OS2.panose.bContrast = view.getByte();
      OS2.panose.bStrokeVariation = view.getByte();
      OS2.panose.bArmStyle = view.getByte();
      OS2.panose.bLetterForm = view.getByte();
      OS2.panose.bMidline = view.getByte();
      OS2.panose.bXHeight = view.getByte();
      OS2.ulUnicodeRange1 = view.getUlongFlags();
      if (OS2.version > 0) {
        OS2.ulUnicodeRange2 = view.getUlongFlags();
        OS2.ulUnicodeRange3 = view.getUlongFlags();
        OS2.ulUnicodeRange4 = view.getUlongFlags();
      }
      OS2.achVendID = view.getString(4);
      OS2.fsSelection = view.getUshortFlags();
      OS2.usFirstCharIndex = view.getUshort();
      OS2.usLastCharIndex = view.getUshort();
      OS2.sTypoAscender = view.getShort();
      OS2.sTypoDescender = view.getShort();
      OS2.sTypoLineGap = view.getShort();
      OS2.usWinAscent = view.getUshort();
      OS2.usWinDescent = view.getUshort();
      if (OS2.version > 0) {
        OS2.ulCodePageRange1 = view.getUlongFlags();
        OS2.ulCodePageRange2 = view.getUlongFlags();
      }
      if (OS2.version > 1) {
        OS2.sxHeight = view.getShort();
        OS2.sCapHeight = view.getShort();
        OS2.usDefaultChar = view.getUshort();
        OS2.usBreakChar = view.getUshort();
        OS2.usMaxContext = view.getUshort();
      }
      return OS2;
    };

    OS_2Table.createFromJSON = function(json) {
      var OS2;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      OS2 = new OS_2Table();
      OS2.version = json.version;
      OS2.xAvgCharWidth = json.xAvgCharWidth;
      OS2.xAvgCharWidth = json.xAvgCharWidth;
      OS2.usWeightClass = json.usWeightClass;
      OS2.usWidthClass = json.usWidthClass;
      OS2.fsType = json.fsType;
      OS2.ySubscriptXSize = json.ySubscriptXSize;
      OS2.ySubscriptYSize = json.ySubscriptYSize;
      OS2.ySubscriptXOffset = json.ySubscriptXOffset;
      OS2.ySubscriptYOffset = json.ySubscriptYOffset;
      OS2.ySuperscriptXSize = json.ySuperscriptXSize;
      OS2.ySuperscriptYSize = json.ySuperscriptYSize;
      OS2.ySuperscriptXOffset = json.ySuperscriptXOffset;
      OS2.ySuperscriptYOffset = json.ySuperscriptYOffset;
      OS2.yStrikeoutSize = json.yStrikeoutSize;
      OS2.yStrikeoutPosition = json.yStrikeoutPosition;
      OS2.sFamilyClass = json.sFamilyClass;
      OS2.panose = json.panose;
      OS2.ulUnicodeRange1 = json.ulUnicodeRange1;
      OS2.ulUnicodeRange2 = json.ulUnicodeRange2;
      OS2.ulUnicodeRange3 = json.ulUnicodeRange3;
      OS2.ulUnicodeRange4 = json.ulUnicodeRange4;
      OS2.achVendID = json.achVendID;
      OS2.fsSelection = json.fsSelection;
      OS2.usFirstCharIndex = json.usFirstCharIndex;
      OS2.usLastCharIndex = json.usLastCharIndex;
      OS2.sTypoAscender = json.sTypoAscender;
      OS2.sTypoDescender = json.sTypoDescender;
      OS2.sTypoLineGap = json.sTypoLineGap;
      OS2.usWinAscent = json.usWinAscent;
      OS2.usWinDescent = json.usWinDescent;
      OS2.ulCodePageRange1 = json.ulCodePageRange1;
      OS2.ulCodePageRange2 = json.ulCodePageRange2;
      OS2.sxHeight = json.sxHeight;
      OS2.sCapHeight = json.sCapHeight;
      OS2.usDefaultChar = json.usDefaultChar;
      OS2.usBreakChar = json.usBreakChar;
      OS2.usMaxContext = json.usMaxContext;
      return OS2;
    };

    return OS_2Table;

  })();


  standardNames = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];

  PostTable = (function() {

    function PostTable() {
      this.version = 0;
      this.italicAngle = 0;
      this.underlinePosition = 0;
      this.underlineThickness = 0;
      this.isFixedPitch = 0;
      this.minMemType42 = 0;
      this.maxMemType42 = 0;
      this.mimMemType1 = 0;
      this.maxMemType1 = 0;
    }

    PostTable.createFromTTFDataView = function(view, offset, ttf) {
      var glyphNameId, glyphNameIndex, i, name, nameLength, names, numGlyphs, post, _i, _j, _k, _ref, _ref1, _ref2;
      view.seek(offset);
      post = new PostTable();
      post.version = view.getFixed();
      post.italicAngle = view.getFixed();
      post.underlinePosition = view.getFWord();
      post.underlineThickness = view.getFWord();
      post.isFixedPitch = view.getUlong();
      post.minMemType42 = view.getUlong();
      post.maxMemType42 = view.getUlong();
      post.minMemType1 = view.getUlong();
      post.maxMemType1 = view.getUlong();
      if (post.version === 1) {
        names = [];
        for (i = _i = 0, _ref = standardNames.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          names.push({
            gId: i,
            name: standardNames[i]
          });
        }
      }
      if (post.version === 2) {
        numGlyphs = view.getUshort();
        glyphNameIndex = [];
        names = [];
        for (i = _j = 0, _ref1 = numGlyphs - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          glyphNameIndex.push(view.getUshort());
        }
        for (i = _k = 0, _ref2 = numGlyphs - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          glyphNameId = "";
          if (glyphNameIndex[i] < standardNames.length) {
            glyphNameId = standardNames[glyphNameIndex[i]];
            name = glyphNameId;
          } else {
            glyphNameId = glyphNameIndex[i] - standardNames.length;
            nameLength = view.getByte();
            name = view.getString(nameLength);
          }
          names.push({
            gId: i,
            name: name
          });
        }
        post.names = names;
      }
      return post;
    };

    PostTable.createFromJSON = function(json) {
      var post;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      post = new PostTable();
      post.version = json.version;
      post.italicAngle = json.italicAngle;
      post.underlinePosition = json.underlinePosition;
      post.underlineThickness = json.underlineThickness;
      post.isFixedPitch = json.isFixedPitch;
      post.minMemType42 = json.minMemType42;
      post.maxMemType42 = json.maxMemType42;
      post.mimMemType1 = json.mimMemType1;
      post.maxMemType1 = json.maxMemType1;
      post.names = json.names;
      return post;
    };

    PostTable.prototype.getGlyphNameById = function(id) {
      var glyphName, name, _i, _len, _ref;
      glyphName = false;
      name = this.names[parseInt(id)];
      if (parseInt(name.gId) === parseInt(id)) {
        glyphName = name.name;
      } else {
        _ref = this.names;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          if (parseInt(name.gId, 10) === parseInt(id, 10)) {
            glyphName = name.name;
          }
        }
      }
      return glyphName;
    };

    return PostTable;

  })();
















  TrueType = (function() {

    function TrueType() {
      this.sfntHeader = {
        sfntVersion: 0,
        numTables: 0,
        searchRange: 0,
        entrySelector: 0,
        rangeShift: 0
      };
      this.offsetTable = [];
      this.head = new HeadTable();
      this.maxp = new MaxpTable();
      this.loca = new LocaTable();
      this.glyf = new GlyfTable();
      this.hhea = new HheaTable();
      this.hmtx = new HmtxTable();
      this.OS_2 = new OS_2Table();
      this.cmap = new CmapTable();
      this.name = new NameTable();
      this.post = new PostTable();
    }

    TrueType.prototype.isMacTTF = function() {
      return this.sfntHeader.sfntVersion === 'true';
    };

    TrueType.prototype.isWinTTF = function() {
      return this.sfntHeader.sfntVersion === 1.0;
    };

    TrueType.prototype.isTTCF = function() {
      return this.sfntHeader.sfntVersion === 'ttcf';
    };

    TrueType.prototype.isTTF = function() {
      return this.isMacTTF() || this.isWinTTF() || this.isTTCF();
    };

    TrueType.prototype.isOTTO = function() {
      return this.sfntHeader.sfntVersion === 'OTTO';
    };

    TrueType.prototype.isCFF = function() {
      return this.isOTTO();
    };

    TrueType.prototype.getNumGlyphs = function() {
      return this.maxp.numGlyphs;
    };

    TrueType.prototype.isLocaLong = function() {
      return this.head.isLocaLong();
    };

    TrueType.prototype.getGlyphById = function(id) {
      var glyphData;
      if (this.getNumGlyphs() === 0) {
        return false;
      }
      glyphData = this.glyf.getGlyphById(id);
      if (glyphData === false) {
        return false;
      }
      return new Glyph(glyphData, this);
    };

    TrueType.prototype.getGlyphNameById = function(id) {
      var name;
      if (this.getNumGlyphs() === 0) {
        return false;
      }
      name = this.post.getGlyphNameById(id);
      if (name === false) {
        return false;
      }
      return name;
    };

    TrueType.createFromBuffer = function(buffer) {
      var checkSum, i, length, offset, sfntVersionNumber, sfntVersionString, tableOffsets, tag, ttf, view;
      ttf = new TrueType();
      view = new TTFDataView(buffer);
      sfntVersionString = view.getString(4, 0);
      sfntVersionNumber = view.getFixed(0);
      ttf.sfntHeader.sfntVersion = sfntVersionNumber === 1.0 ? sfntVersionNumber : sfntVersionString;
      if (ttf.isTTF() && !ttf.isTTCF() || ttf.isOTTO()) {
        ttf.sfntHeader.numTables = view.getUshort(4);
        ttf.sfntHeader.searchRange = view.getUshort();
        ttf.sfntHeader.entrySelector = view.getUshort();
        ttf.sfntHeader.rangeShift = view.getUshort();
        if (ttf.sfntHeader.numTables > 0) {
          tableOffsets = {};
          ttf.offsetTable = (function() {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ttf.sfntHeader.numTables - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              tag = view.getString(4);
              checkSum = view.getUlong().toString(16);
              offset = view.getUlong();
              length = view.getUlong();
              tableOffsets[tag] = offset;
              _results.push({
                tag: tag,
                checkSum: checkSum,
                offset: offset,
                length: length
              });
            }
            return _results;
          })();
          if (typeof tableOffsets.head !== 'undefined') {
            ttf.head = HeadTable.createFromTTFDataView(view, tableOffsets.head, ttf);
          }
          if (typeof tableOffsets.maxp !== 'undefined') {
            ttf.maxp = MaxpTable.createFromTTFDataView(view, tableOffsets.maxp, ttf);
          }
          if (typeof tableOffsets.loca !== 'undefined') {
            ttf.loca = LocaTable.createFromTTFDataView(view, tableOffsets.loca, ttf);
          }
          if (typeof tableOffsets.glyf !== 'undefined') {
            ttf.glyf = GlyfTable.createFromTTFDataView(view, tableOffsets.glyf, ttf);
          }
          if (typeof tableOffsets.hhea !== 'undefined') {
            ttf.hhea = HheaTable.createFromTTFDataView(view, tableOffsets.hhea, ttf);
          }
          if (typeof tableOffsets.hmtx !== 'undefined') {
            ttf.hmtx = HmtxTable.createFromTTFDataView(view, tableOffsets.hmtx, ttf);
          }
          if (typeof tableOffsets['OS/2'] !== 'undefined') {
            ttf.OS_2 = OS_2Table.createFromTTFDataView(view, tableOffsets['OS/2'], ttf);
          }
          if (typeof tableOffsets['cmap'] !== 'undefined') {
            ttf.cmap = CmapTable.createFromTTFDataView(view, tableOffsets['cmap'], ttf);
          }
          if (typeof tableOffsets['name'] !== 'undefined') {
            ttf.name = NameTable.createFromTTFDataView(view, tableOffsets['name'], ttf);
          }
          if (typeof tableOffsets['post'] !== 'undefined') {
            ttf.post = PostTable.createFromTTFDataView(view, tableOffsets['post'], ttf);
          }
          if (typeof tableOffsets['GDEF'] !== 'undefined') {
            ttf.GDEF = GDEFTable.createFromTTFDataView(view, tableOffsets['GDEF'], ttf);
          }
          if (typeof tableOffsets['GPOS'] !== 'undefined') {
            ttf.GPOS = GPOSTable.createFromTTFDataView(view, tableOffsets['GPOS'], ttf);
          }
        }
      }
      return ttf;
    };

    TrueType.createFromJSON = function(json) {
      var ttf;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      ttf = new TrueType();
      ttf.sfntHeader.sfntVersion = json.sfntHeader.sfntVersion;
      if (ttf.isTTF() && !ttf.isTTCF() || ttf.isOTTO()) {
        ttf.sfntHeader.numTables = json.sfntHeader.numTables;
        ttf.sfntHeader.searchRange = json.sfntHeader.searchRange;
        ttf.sfntHeader.entrySelector = json.sfntHeader.entrySelector;
        ttf.sfntHeader.rangeShift = json.sfntHeader.rangeShift;
        if (ttf.sfntHeader.numTables > 0) {
          ttf.offsetTable = json.offsetTable;
          if (typeof json.head !== 'undefined') {
            ttf.head = HeadTable.createFromJSON(json.head);
          }
          if (typeof json.maxp !== 'undefined') {
            ttf.maxp = MaxpTable.createFromJSON(json.maxp);
          }
          if (typeof json.loca !== 'undefined') {
            ttf.loca = LocaTable.createFromJSON(json.loca);
          }
          if (typeof json.glyf !== 'undefined') {
            ttf.glyf = GlyfTable.createFromJSON(json.glyf);
          }
          if (typeof json.hhea !== 'undefined') {
            ttf.hhea = HheaTable.createFromJSON(json.hhea);
          }
          if (typeof json.hmtx !== 'undefined') {
            ttf.hmtx = HmtxTable.createFromJSON(json.hmtx);
          }
          if (typeof json.OS_2 !== 'undefined') {
            ttf.OS_2 = OS_2Table.createFromJSON(json.OS_2);
          }
          if (typeof json.cmap !== 'undefined') {
            ttf.cmap = CmapTable.createFromJSON(json.cmap);
          }
          if (typeof json.name !== 'undefined') {
            ttf.cmap = NameTable.createFromJSON(json.name);
          }
          if (typeof json.post !== 'undefined') {
            ttf.cmap = PostTable.createFromJSON(json.post);
          }
          if (typeof json.GDEF !== 'undefined') {
            ttf.GDEF = GDEFTable.createFromJSON(json.GDEF);
          }
          if (typeof json.GPOS !== 'undefined') {
            ttf.GPOS = GPOSTable.createFromJSON(json.GPOS);
          }
        }
      }
      return ttf;
    };

    TrueType.prototype.toJSONString = function() {
      var glyph, json, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.glyf.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glyph = _ref[_i];
        glyph.glyfTable = '[GlyfTable]';
      }
      json = JSON.stringify.apply(null, [this].concat(arguments));
      _ref1 = this.glyf.glyphs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        glyph = _ref1[_j];
        glyph.glyfTable = this.glyf;
      }
      return json;
    };

    return TrueType;

  })();


  jDataView = typeof require !== 'undefined' ? require('jdataview') : this.jDataView;

  TTFDataView = (function() {

    function TTFDataView(buffer) {
      this.buffer = buffer;
      this.view = new jDataView(this.buffer);
    }

    TTFDataView.prototype.seek = function(offset) {
      if (typeof offset === 'number') {
        this.view.seek(offset);
      }
      return this;
    };

    TTFDataView.prototype.tell = function() {
      return this.view.tell();
    };

    TTFDataView.prototype.getString = function(length, offset) {
      return this.view.getString(length, offset);
    };

    TTFDataView.prototype.getByte = function(offset) {
      return this.view.getUint8(offset);
    };

    TTFDataView.prototype.getChar = function(offset) {
      return this.view.getInt8(offset);
    };

    TTFDataView.prototype.getUshort = function(offset) {
      return this.view.getUint16(offset);
    };

    TTFDataView.prototype.getShort = function(offset) {
      return this.view.getInt16(offset);
    };

    TTFDataView.prototype.getUlong = function(offset) {
      return this.view.getUint32(offset);
    };

    TTFDataView.prototype.getLong = function(offset) {
      return this.view.getInt32(offset);
    };

    /**
     * Return 32-bit signed fixed-point number (16.16).
     * @param {number} `offset` offset.
    */


    TTFDataView.prototype.getFixed = function(offset) {
      var fraction, mantissa;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      mantissa = this.view.getInt16();
      fraction = this.view.getUint16() / Math.pow(2, 16);
      return Math.ceil((mantissa + fraction) * 1000) / 1000;
    };

    TTFDataView.prototype.getF2dot14 = function(offset) {
      var fraction, mantissa, value;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      value = this.view.getUint16();
      mantissa = [0, 1, -2, -1][value >>> 14];
      fraction = (value & 0x3fff) / Math.pow(2, 14);
      return Math.round((mantissa + fraction) * 1000000) / 1000000;
    };

    TTFDataView.prototype.getUint24 = function(offset) {
      var b;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      b = [];
      b[0] = this.getByte();
      b[1] = this.getByte();
      b[2] = this.getByte();
      return (b[0] << 16) + (b[1] << 8) + b[2];
    };

    /**
     * Return the long internal format of a date
     * in seconds since 12:00 midnight, January 1, 1904.
     * It is represented as a signed 64-bit integer.<br />
     *
     * This method has been ported form the FontForge. <br />
     * https://github.com/fontforge/fontforge/blob/v20120731-b/fonttools/showttf.c#L483-L516
     * @param {number} offset offset.
     * @return {Date} date.
    */


    TTFDataView.prototype.getLongDateTime = function(offset) {
      var date, date1970, i, unixtime, year, _i, _j;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      date = [0, 0, 0, 0];
      date1970 = [0, 0, 0, 0];
      year = [];
      date[3] = this.getUshort();
      date[2] = this.getUshort();
      date[1] = this.getUshort();
      date[0] = this.getUshort();
      year[0] = (60 * 60 * 24 * 365) & 0xffff;
      year[1] = (60 * 60 * 24 * 365) >> 16;
      for (i = _i = 1904; _i <= 1969; i = ++_i) {
        date1970[0] += year[0];
        date1970[1] += year[1];
        if ((i & 3) === 0 && (i % 100 !== 0 || i % 400 === 0)) {
          date1970[0] += 24 * 60 * 60;
        }
        date1970[1] += date1970[0] >> 16;
        date1970[0] &= 0xffff;
        date1970[2] += date1970[1] >> 16;
        date1970[1] &= 0xffff;
        date1970[3] += date1970[2] >> 16;
        date1970[2] &= 0xffff;
      }
      for (i = _j = 0; _j <= 3; i = ++_j) {
        date[i] -= date1970[i];
        date[i + 1] += date[i] >> 16;
        date[i] &= 0xffff;
      }
      date[3] -= date1970[3];
      unixtime = ((date[1] << 16) | date[0]) * 1000;
      return new Date(unixtime);
    };

    TTFDataView.prototype.getUFWord = function(offset) {
      return this.getUshort(offset);
    };

    TTFDataView.prototype.getFWord = function(offset) {
      return this.getShort(offset);
    };

    TTFDataView.prototype.getUshortFlags = function(offset) {
      var flags, i, num, _i, _results;
      flags = this.getUshort(offset);
      _results = [];
      for (i = _i = 0; _i <= 15; i = ++_i) {
        _results.push(num = (flags & Math.pow(2, i)) === 0 ? 0 : 1);
      }
      return _results;
    };

    TTFDataView.prototype.getUlongFlags = function(offset) {
      var flags, i, num, _i, _results;
      flags = this.getUlong(offset);
      _results = [];
      for (i = _i = 0; _i <= 31; i = ++_i) {
        _results.push(num = (flags & Math.pow(2, i)) === 0 ? 0 : 1);
      }
      return _results;
    };

    return TTFDataView;

  })();


  TTFString = (function() {

    function TTFString() {}

    TTFString.codePointAt = function(string, position) {
      var first, index, second, size;
      string = String(string);
      size = string.length;
      index = typeof position !== 'undefined' ? Number(position) : 0;
      if (isNaN(index)) {
        index = 0;
      }
      if (index < 0 || index >= size) {
        return void 0;
      }
      first = string.charCodeAt(index);
      second = void 0;
      if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
        second = string.charCodeAt(index + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }
      return first;
    };

    TTFString.fromCodePoint = function() {
      var codePoint, codeUnits, floor, highSurrogate, index, length, lowSurrogate;
      codeUnits = [];
      floor = Math.floor;
      highSurrogate;

      lowSurrogate;

      index = -1;
      length = arguments.length;
      if (!length) {
        return '';
      }
      while (++index < length) {
        codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) !== codePoint) {
          throw RangeError('Invalid code point: ' + codePoint);
        }
        if (codePoint <= 0xFFFF) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = (codePoint % 0x400) + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
      }
      return String.fromCharCode.apply(null, codeUnits);
    };

    return TTFString;

  })();


  /*
  require
  */


  if (typeof module !== 'undefined') {
  }

  /*
  exports
  */


  ttfjs = {
    TrueType: TrueType,
    util: {
      TTFDataView: TTFDataView,
      TTFString: TTFString
    },
    table: {
      HeadTable: HeadTable,
      LocaTable: LocaTable,
      MaxpTable: MaxpTable,
      GlyfTable: GlyfTable,
      HheaTable: HheaTable,
      HmtxTable: HmtxTable,
      OS_2Table: OS_2Table
    },
    glyph: {
      SimpleGlyphData: SimpleGlyphData,
      CompositeGlyphData: CompositeGlyphData
    }
  };

  if (typeof module !== 'undefined') {
    module.exports = ttfjs;
  } else {
    this.ttfjs = ttfjs;
  }

}).call(this);
